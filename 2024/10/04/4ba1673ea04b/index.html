<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>不基础的python基础-补 | Pengunix</title><meta name="author" content="Pengunix"><meta name="copyright" content="Pengunix"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="python一些细节开始此文档目的是对python的细节进行补充，内容和知识点比较零散，更新时间不定。 1.1 默认参数已知如下代码1234class Player:    def __init__(self, name, items):        self.name &#x3D; name        self.items &#x3D; items情形1:当我实例化两个玩家时12p1 &#x3D; Player(&quot;al">
<meta property="og:type" content="article">
<meta property="og:title" content="不基础的python基础-补">
<meta property="og:url" content="https://blog.pengunix.icu/2024/10/04/4ba1673ea04b/index.html">
<meta property="og:site_name" content="Pengunix">
<meta property="og:description" content="python一些细节开始此文档目的是对python的细节进行补充，内容和知识点比较零散，更新时间不定。 1.1 默认参数已知如下代码1234class Player:    def __init__(self, name, items):        self.name &#x3D; name        self.items &#x3D; items情形1:当我实例化两个玩家时12p1 &#x3D; Player(&quot;al">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bing.img.run/rand_1366x768.php">
<meta property="article:published_time" content="2024-10-04T06:07:58.000Z">
<meta property="article:modified_time" content="2024-10-04T06:29:23.863Z">
<meta property="article:author" content="Pengunix">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bing.img.run/rand_1366x768.php"><link rel="shortcut icon" href="/images/fav.png"><link rel="canonical" href="https://blog.pengunix.icu/2024/10/04/4ba1673ea04b/index.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.11.1/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '不基础的python基础-补',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-04 14:29:23'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://bing.img.run/rand_1366x768.php')"><nav id="nav"><span id="blog-info"><a href="/" title="Pengunix"><img class="site-icon" src="/images/logo.png"/></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">不基础的python基础-补</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-04T06:07:58.000Z" title="发表于 2024-10-04 14:07:58">2024-10-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-04T06:29:23.863Z" title="更新于 2024-10-04 14:29:23">2024-10-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="python一些细节"><a href="#python一些细节" class="headerlink" title="python一些细节"></a>python一些细节</h2><p>开始此文档目的是对python的细节进行补充，内容和知识点比较零散，更新时间不定。</p>
<h3 id="1-1-默认参数"><a href="#1-1-默认参数" class="headerlink" title="1.1 默认参数"></a>1.1 默认参数</h3><p>已知如下代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, items</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.items = items</span><br></pre></td></tr></table></figure><br>情形1:<br>当我实例化两个玩家时<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 = Player(<span class="string">"alice"</span>, [])</span><br><span class="line">p2 = Player(<span class="string">"Bob"</span>, [])</span><br></pre></td></tr></table></figure><br>会发现大部分玩家默认都没有任何道具。<br>此时，想到python重载机制，利用默认参数进行重载。<br>既然大部分玩家默认没有道具，能否定义一个默认参数对每一个玩家进行初始化呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, items=[]</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.items = items</span><br></pre></td></tr></table></figure><br>这样，在进行实例化时，无需传入一个默认的道具参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1 = Player(<span class="string">"alice"</span>)</span><br><span class="line">p2 = Player(<span class="string">"bob"</span>)</span><br><span class="line">p3 = Player(<span class="string">"Charles"</span>, [<span class="string">"sword"</span>])</span><br></pre></td></tr></table></figure><br>问题出现，当玩家获取了道具时<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p1.items.append(<span class="string">"bow"</span>)</span><br><span class="line">p2.items.append(<span class="string">"sword"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 问题</span></span><br><span class="line"><span class="built_in">print</span>(p1.items)</span><br><span class="line">OUT: [<span class="string">"bow"</span>, <span class="string">"sword"</span>]</span><br></pre></td></tr></table></figure><br>当定义默认参数时，只会evaluate一次值，也就是只求一次值。意味着两次初始化items用的是同一个list。<br>list 为mutable，所以二者共用了一个list<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(<span class="variable language_">self</span>.items))</span><br><span class="line"><span class="comment"># 两次输出的id相同</span></span><br></pre></td></tr></table></figure><br>解决方法: 将<code>items=[]</code>改为<code>items=None</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, items=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="keyword">if</span> items <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        	<span class="variable language_">self</span>.items = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.items = items</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-浮点数"><a href="#1-2-浮点数" class="headerlink" title="1.2 浮点数"></a>1.2 浮点数</h3><p>如下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> objprint <span class="keyword">import</span> op</span><br><span class="line">op.config(arg_name=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">op(<span class="number">0.1</span>+<span class="number">0.2</span>==<span class="number">0.3</span>)</span><br><span class="line">op(<span class="number">1e50</span>==<span class="number">10</span>**<span class="number">50</span>)</span><br><span class="line">op(<span class="number">1e500</span>==<span class="number">1e600</span>)</span><br><span class="line">op(<span class="number">1e500</span>&gt;<span class="number">10</span>**<span class="number">1000</span>)</span><br><span class="line">op(<span class="number">1e500</span>*<span class="number">1e500</span>&gt;<span class="number">0</span>)</span><br><span class="line">op(<span class="number">1e500</span>/<span class="number">1e500</span>&gt;<span class="number">0</span>)</span><br><span class="line">op(<span class="number">1e500</span>/<span class="number">1e500</span>==<span class="number">1e500</span>/<span class="number">1e500</span>)</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0.1+0.2==0.3:</span><br><span class="line">False</span><br><span class="line">1e50==10**50:</span><br><span class="line">False</span><br><span class="line">1e500==1e600:</span><br><span class="line">True</span><br><span class="line">1e500&gt;10**1000:</span><br><span class="line">True</span><br><span class="line">1e500*1e500&gt;0:</span><br><span class="line">True</span><br><span class="line">1e500/1e500&gt;0:</span><br><span class="line">False</span><br><span class="line">1e500/1e500==1e500/1e500:</span><br><span class="line">False</span><br></pre></td></tr></table></figure><br><a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/IEEE754">关于浮点数的知识</a><br>计算机实现浮点数都使用IEEE754标准，由于浮点数的总体是无限且不可数的，我们不可能在计算机中完整地记录所有数字。</p>
<blockquote>
<p>IEEE754标准提供了二进制转浮点数的标准 具体内容<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/IEEE754">IEEE754</a><br>从而就产生了以上问题<br>问题1: 精度损失</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">op(<span class="number">0.1</span>+<span class="number">0.2</span>==<span class="number">0.3</span>)</span><br><span class="line"><span class="number">0.1</span>+<span class="number">0.2</span>==<span class="number">0.3</span>:</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="comment"># python 中 1e50会被转为float而10**50会被当成一个big integer</span></span><br><span class="line"><span class="comment"># python中，整型是绝对精确的，浮点数不是。</span></span><br><span class="line"><span class="comment"># 故浮点数比较不应该使用==。而是比较两个数差值的绝对值是否小于一个比较小的值 0.00001</span></span><br><span class="line">op(<span class="number">1e50</span>==<span class="number">10</span>**<span class="number">50</span>)</span><br><span class="line"><span class="number">1e50</span>==<span class="number">10</span>**<span class="number">50</span>:</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>问题2:<br>python使用64位双精度浮点数，其有最大的能表示的浮点数，对于双精度浮点数来说，这个数大概是10的308次方。<br>超出了这个数字：IEEE754提供了无穷( Inf )和非数值( NaN )两种表示形式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1e500超过了双精度浮点数最大能表示的范围，python将其转换成了Inf,1e600同理。</span></span><br><span class="line"><span class="comment"># 所以以下代码比较的是Inf 是否等于 Inf 详见IEEE754。</span></span><br><span class="line">op(<span class="number">1e500</span>==<span class="number">1e600</span>)</span><br><span class="line"><span class="number">1e500</span>==<span class="number">1e600</span>:</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 比较方式 -Inf = -Inf, Inf=Inf, NaN与任何浮点数（包括自身）的比较都为假。</span></span><br><span class="line"><span class="comment"># python在比较如下代码时如果这个float是Inf，则认为永远比integer要大。</span></span><br><span class="line">op(<span class="number">1e500</span>&gt;<span class="number">10</span>**<span class="number">1000</span>)</span><br><span class="line"><span class="number">1e500</span>&gt;<span class="number">10</span>**<span class="number">1000</span>:</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 既然如此 以下各数都是+Inf 正无穷乘以正无穷一定是大于0的。</span></span><br><span class="line"><span class="comment"># 但正无穷除以正无穷可能是大于等于零的任何值。</span></span><br><span class="line"><span class="comment"># 所以 Inf / Inf = NaN 不是数字 NaN当然不大于零。</span></span><br><span class="line">op(<span class="number">1e500</span>*<span class="number">1e500</span>&gt;<span class="number">0</span>)</span><br><span class="line">op(<span class="number">1e500</span>/<span class="number">1e500</span>&gt;<span class="number">0</span>)</span><br><span class="line"><span class="number">1e500</span>*<span class="number">1e500</span>&gt;<span class="number">0</span>:</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="number">1e500</span>/<span class="number">1e500</span>&gt;<span class="number">0</span>:</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="comment"># 左边是NaN右边也是NaN, 他们也不相等</span></span><br><span class="line">op(<span class="number">1e500</span>/<span class="number">1e500</span>==<span class="number">1e500</span>/<span class="number">1e500</span>)</span><br><span class="line"><span class="number">1e500</span>/<span class="number">1e500</span>==<span class="number">1e500</span>/<span class="number">1e500</span>:</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><br>综上，float可能会给程序带来意想不到的结果。<br>例如，在一些大型的数学计算中，中间的某一个过程出现了Inf或是NaN，他会随着计算将各种结果传染成Inf或NaN。<br>而且，程序不会报错，你无法意识到问题所在。<br>所以，要尽量避开浮点数。<br>如果不可避免，可使用以下方式检查关键步骤是否为Inf或NaN。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">math.isinf(Var)</span><br><span class="line">math.isnan(Var)</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3-class里的函数如何变成方法的-self作用"><a href="#1-3-class里的函数如何变成方法的-self作用" class="headerlink" title="1.3 class里的函数如何变成方法的(self作用)"></a>1.3 class里的函数如何变成方法的(self作用)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, data</span>): <span class="comment"># &lt;-定义了两个位置参数</span></span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">o = A()</span><br><span class="line">o.f(<span class="string">"hello"</span>) <span class="comment"># &lt;- 实际传入了一个 </span></span><br><span class="line"><span class="comment"># self保存了本身的对象</span></span><br></pre></td></tr></table></figure>
<p>在定义class时会创建一个命名空间，运行class里的code block,将里面的产生的local variable赋值到<code>__dict__()</code>里面。<br>为什么只需要传入一个位置参数呢<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, data</span>): <span class="comment"># &lt;-定义了两个位置参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name)</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">o = A()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.f)</span><br><span class="line"><span class="comment"># 只有实例化之后才只需传入一个值</span></span><br><span class="line"><span class="built_in">print</span>(o.f)</span><br><span class="line">返回：</span><br><span class="line">&lt;function A.f at <span class="number">0x7f7444387eb0</span>&gt;</span><br><span class="line">&lt;bound method A.f of &lt;__main__.A <span class="built_in">object</span> at <span class="number">0x7f74443957e0</span>&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name)</span><br><span class="line">        </span><br><span class="line">o = A()</span><br><span class="line">o.name = <span class="string">"sam"</span></span><br><span class="line"></span><br><span class="line">myfunc = o.f  <span class="comment"># o.f实际上返回绑定在o本身上的一个方法 调用时不需要传入self</span></span><br><span class="line"><span class="comment"># 可以理解 f 在实例化时就已经改变，并不是最初定义的f</span></span><br><span class="line">myfunc(<span class="string">"hello"</span>)</span><br><span class="line">返回</span><br><span class="line">hello</span><br><span class="line">sam</span><br></pre></td></tr></table></figure>
<h3 id="1-4-鸭子类型"><a href="#1-4-鸭子类型" class="headerlink" title="1.4 鸭子类型"></a>1.4 鸭子类型</h3><blockquote>
<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”<br>鸭子类型是动态类型的一种风格，在这个风格中一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由“当前方法和属性的集合”决定</p>
</blockquote>
<p>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可迭代对象</span></span><br><span class="line">a = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"><span class="comment"># 我们可以使用 for 循环来遍历他</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 现有自定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 使用 for 循环必然会报错 此时 可以为类 B 添加一个 __iter__()方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># 同理 我们可以使用len()函数来查看一个对象的长度</span></span><br><span class="line"><span class="built_in">len</span>(a)</span><br><span class="line"><span class="comment"># 如何使类B也能使用len函数查看长度呢</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><br>总结 python不会检查某个类是什么类型，他只会检查是否含有对应方法。</p>
<h3 id="1-5-assert-关键字"><a href="#1-5-assert-关键字" class="headerlink" title="1.5 assert 关键字"></a>1.5 assert 关键字</h3><p>assert 意为断言 当 后面的表达式为假时抛出<strong>AssertionError</strong><br>例如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果条件返回True，则什么也不会发生：</span></span><br><span class="line"><span class="keyword">assert</span> x == <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果条件返回 False，则会引发 AssertionError：</span></span><br><span class="line"><span class="keyword">assert</span> x == <span class="string">"goodbye"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="1-6-找到可迭代对象共同的接口"><a href="#1-6-找到可迭代对象共同的接口" class="headerlink" title="1.6 找到可迭代对象共同的接口"></a>1.6 找到可迭代对象共同的接口</h3><h4 id="常见的可迭代对象"><a href="#常见的可迭代对象" class="headerlink" title="常见的可迭代对象"></a>常见的可迭代对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">iterables = [</span><br><span class="line">    <span class="string">"123"</span>,          <span class="comment"># 字符串</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],      <span class="comment"># 列表</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,),     <span class="comment"># 元组</span></span><br><span class="line">    {<span class="number">1</span>:<span class="string">"a"</span>, <span class="number">2</span>:<span class="string">"b"</span>}, <span class="comment"># 字典</span></span><br><span class="line">    {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}       <span class="comment"># 集合</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> iterable <span class="keyword">in</span> iterables:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(iterable))</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="built_in">print</span>(x, end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>利用python 强大的类型能力<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">common_attrs</span>(<span class="params">*objs</span>):</span><br><span class="line">    <span class="string">"""计算对象之间的共同属性"""</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(objs) &gt; <span class="number">0</span></span><br><span class="line">    attrs = <span class="built_in">set</span>(<span class="built_in">dir</span>(objs[<span class="number">0</span>]))</span><br><span class="line">	<span class="keyword">for</span> obj <span class="keyword">in</span> objs[<span class="number">1</span>:]:</span><br><span class="line">        attrs &amp;= <span class="built_in">set</span>(<span class="built_in">dir</span>(obj)) <span class="comment"># 取交集</span></span><br><span class="line">    attrs -= <span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="built_in">object</span>)) <span class="comment"># 删除object 基础对象属性</span></span><br><span class="line">    <span class="keyword">return</span> attrs</span><br><span class="line">iterable_common_attrs = common_attrs(*iterables)</span><br><span class="line"><span class="built_in">print</span>(iterable_common_attrs)</span><br></pre></td></tr></table></figure><br>返回三个结果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__contains__ __len__ __iter__</span><br></pre></td></tr></table></figure><br>这里列举的对象都是容器类型的可迭代对象<br>加入文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">"..."</span>, <span class="string">"r"</span>) <span class="comment"># 文件也是可迭代对象</span></span><br><span class="line"><span class="comment"># 加入到可迭代对象清单中</span></span><br><span class="line">iterables.append(f)</span><br><span class="line">iterable_common_attrs &amp;= <span class="built_in">set</span>(<span class="built_in">dir</span>(f))</span><br><span class="line"><span class="built_in">print</span>(iterable_common_attrs)</span><br></pre></td></tr></table></figure><br>返回<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__iter__</span><br></pre></td></tr></table></figure><br>对于双下划线的魔法方法 <code>__iter__()</code>，对应的调用方法就是内置函数iter()<br>对所有的可迭代对象调用<code>iter()</code>方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> iterable <span class="keyword">in</span> iterables:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">iter</span>(iterable))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;str_iterator object at 0x7f07f2c3c700&gt;</span><br><span class="line">&lt;list_iterator object at 0x7f07f2c3c700&gt;</span><br><span class="line">&lt;tuple_iterator object at 0x7f07f2c3c700&gt;</span><br><span class="line">&lt;dict_keyiterator object at 0x7f07f2a520c0&gt;</span><br><span class="line">&lt;set_iterator object at 0x7f07f2a56640&gt;</span><br><span class="line">&lt;_io.TextIOWrapper name='test.ui' mode='r' encoding='UTF-8'&gt;</span><br></pre></td></tr></table></figure>
<p>此外 由可迭代对象列表得到相应的迭代器列表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iterators = [<span class="built_in">iter</span>(iterable) <span class="keyword">for</span> iterable <span class="keyword">in</span> iterables]</span><br><span class="line">iterator_common_attrs = common_attrs(*iterators)</span><br><span class="line"><span class="built_in">print</span>(iterator_common_attrs)```</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>{‘<strong>next</strong>‘, ‘<strong>iter</strong>‘}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">所以 迭代器有两个共同接口 `__iter__` 和 `__next__` 迭代器也是一个可迭代对象</span><br><span class="line">#### 关于next魔法方法</span><br><span class="line">![image-20220528140933468](image-20220528140933468.png)</span><br><span class="line">至此 我们了解到迭代的三个步骤：</span><br><span class="line">* 调用 `iter(iterable)`来构建迭代器</span><br><span class="line">* （多次）调用`next(iterator)`来获取值</span><br><span class="line">* 最后捕获`StopIteration`异常来判断迭代结束</span><br><span class="line">现在 我们可以使用`while循环`来模拟`for循环`迭代</span><br><span class="line">```python</span><br><span class="line"># 创建迭代器</span><br><span class="line">iterator = iter(actions) # 对应可迭代对象的 __iter__ 方法</span><br><span class="line">while 1:</span><br><span class="line">    try:</span><br><span class="line">        # 通过迭代器获取下一个对象</span><br><span class="line">        print(next(iterator)) # 对应迭代器的 __next__ 方法</span><br><span class="line">        except StopIteration:</span><br><span class="line">            # 迭代结束 跳出循环</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><br>迭代器的<code>__iter__</code>方法作用是什么呢？</p>
<h4 id="了解如何定义一个迭代器"><a href="#了解如何定义一个迭代器" class="headerlink" title="了解如何定义一个迭代器"></a>了解如何定义一个迭代器</h4><p>迭代器的基本功能：</p>
<ul>
<li>初始化时要传入可迭代对象，这样才能知道去哪里取数据</li>
<li>要初始化迭代进度</li>
<li>每次迭代调用<code>__iter__()</code>方法时：<ul>
<li>如果仍有元素可以迭代，则返回本轮迭代的元素，同时更新当前迭代进度<ul>
<li>如果无元素可以迭代，则迭代结束，抛出<code>StopIteration</code>异常<br>看起来没什么作用，所以我们可以给迭代器添加额外的功能</li>
</ul>
</li>
</ul>
</li>
<li>设置一个黑名单，如果当前元素在黑名单内，则跳过</li>
<li>将某些符合条件的数据<code>*2</code>后返回<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BLACK_LIST = [<span class="string">"白嫖"</span>, <span class="string">"取关"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuzhiIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, actions</span>):</span><br><span class="line">        <span class="variable language_">self</span>.actions = actions</span><br><span class="line">        <span class="variable language_">self</span>.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.index &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>.actions):</span><br><span class="line">            action = <span class="variable language_">self</span>.actions[<span class="variable language_">self</span>.index]</span><br><span class="line">            <span class="variable language_">self</span>.index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> action <span class="keyword">in</span> BLACK_LIST:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="string">'硬币'</span> <span class="keyword">in</span> action:</span><br><span class="line">                <span class="keyword">return</span> action * <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> action</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">actions = [<span class="string">'点赞'</span>,<span class="string">'投币'</span>,<span class="string">'取关'</span>]</span><br><span class="line">sz_iterator = SuzhiIterator(actions)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(sz_iterator))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
以上代码运行起来沒什么问题<br>但当我们使用<code>for 循环</code>来遍历时 会报错<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 循环需要的是 可迭代对象 而不是迭代器</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> SuzhiIterator(actions):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    </span><br><span class="line">TypeError: <span class="string">'SuzhiIterator'</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> iterable</span><br></pre></td></tr></table></figure>
要想这个对象是<code>iterable</code> 那么你需要实现<code>__iter__</code>接口<br>为了构建这个可迭代对象 可以再新建一个类<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuzhiActions</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, actions</span>):</span><br><span class="line">        <span class="variable language_">self</span>.actions = actions</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> SuzhiIterator(<span class="variable language_">self</span>.actions) <span class="comment"># return self 也可</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> SuzhiActions(actions):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
当然 这样做 显然有点多余 因为他只完成了构建可迭代对象的过程<br>通常这样 让迭代器自己来实现<code>__iter__</code>接口<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __iter__ 接口就是要返回一个迭代器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span></span><br></pre></td></tr></table></figure>
现在 迭代器就可以在<code>for 循环</code>中使用了<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代器 同时 也是 可迭代对象</span></span><br></pre></td></tr></table></figure>
<h4 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h4>在python文档中明确指出了，迭代器对象必须同时实现<code>__next__</code>和<code>__iter__</code>两个方法，这称为<strong>迭代器协议</strong>。<br>根据这个协议，迭代器<strong>必须</strong>是可迭代的，换言之，<strong>迭代器 是一种 可迭代对象 </strong>。<br>故缺少了<code>__iter__</code>方法的迭代器是不完整的，不符合迭代器协议的要求。<br>所有迭代器的<code>__iter__</code>方法大多数都只要<code>return self</code>即可。<h4 id="迭代器的意义"><a href="#迭代器的意义" class="headerlink" title="迭代器的意义"></a>迭代器的意义</h4>浅层的意义</li>
<li>统一通过<code>next()</code>方法获取数据，可以屏蔽底层不同的数据读取方式，从而简化编程。</li>
<li>容器类的数据结构只关心数据的金泰存储，每一次迭代都需要额外的迭代器对象专门负责记录迭代过程中的状态信息。<br>按照这个思路 很容易形成这样的认知：迭代器就是为了让数据能够更快捷地遍历 从而定义的辅助对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这一些迭代对象对我们来说非常陌生，不会去使用他们，所以这种认知在这个层面上来讲，是没有错误的。</span><br><span class="line">&lt;str_iterator object at 0x7f07f2c3c700&gt;</span><br><span class="line">&lt;list_iterator object at 0x7f07f2c3c700&gt;</span><br><span class="line">&lt;tuple_iterator object at 0x7f07f2c3c700&gt;</span><br><span class="line">&lt;dict_keyiterator object at 0x7f07f2a520c0&gt;</span><br><span class="line">&lt;set_iterator object at 0x7f07f2a56640&gt;</span><br><span class="line">&lt;_io.TextIOWrapper name='test.ui' mode='r' encoding='UTF-8'&gt;</span><br></pre></td></tr></table></figure>
迭代器的作用并不止于此。<br>如果只是在<code>for 循环</code>中使用，是无需用到迭代器的<code>__iter__</code>方法的，就像前面使用<code>while循环</code>来模拟<code>for循环</code>。<br>深层意义<br>迭代器的<code>__iter__</code>方法是点睛之笔！<br>对此，我们分一下类<br>现在有两种可迭代对象</li>
<li><p>容器类型的</p>
<ul>
<li>列表、元组、字典等</li>
<li>只有<code>__iter__</code>接口</li>
<li>静态的数据</li>
<li>需要额外的迭代器支持</li>
<li>支持多次迭代</li>
</ul>
</li>
<li><p>迭代器类型</p>
<ul>
<li>文件、 StringIO等</li>
<li>同时实现<code>__iter__</code>和<code>__next__</code>接口</li>
<li>动态的</li>
<li>只能迭代一次<br>也就是说<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对容器类型可迭代对象的循环</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> iterable: <span class="comment"># 背后： 将可迭代对象 生成了 迭代器</span></span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 迭代器的生命周期和此循环绑定在一起</span></span><br></pre></td></tr></table></figure>
而一旦迭代器实现了<code>__iter__</code>方法<br>首先迭代器的构建就脱离的这个循环的存在，整个迭代过程只需要迭代器就够了<br>从此 迭代器不光是从后台走向了前台，而且直接让可迭代对象原理了循环<br>迭代器的构建是在代码中单独完成的，和当前循环操作<strong>解耦</strong>了<br>于是：</li>
</ul>
</li>
<li>一个可迭代对象可以构建出任意多个不同的迭代器</li>
<li>一种迭代器可以应用有v任意多个可迭代对象（包括其他迭代器）<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4></li>
</ul>
<ol>
<li>构建一个数据管道<br>如果迭代器不可迭代：<br>三者关系如下<br>[for循环] &lt;- 迭代器（隐藏） &lt;- 可迭代对象<br>如果迭代器可以任意嵌套连接的：<br>for 循环 &lt;- 迭代器 &lt;-迭代器 &lt;- 迭代器 &lt;- 迭代器*n &lt;- 可迭代对象</li>
</ol>
<ul>
<li>很多的迭代器串联起来，形成一个处理数据v的管道，或者称为数据流</li>
<li>在这个管道中，每一次只通过一份数据v,避免了一次性加载所有数据</li>
<li>迭代器也不仅仅只是按返回数据那么简单了，他开始承担处理数据的责任<ul>
<li>例如， <code>SuzhiIterator</code>实现了部分过滤器和放大器的功能</li>
</ul>
</li>
<li>当通过迭代器获取数据的时候，远离了数据存储，渐渐开始不关心数据如何存储。</li>
</ul>
<ol>
<li>数据生成器<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Random</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> random()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个迭代器不但不需要存储数据，甚至连<code>StopIteration</code>都不需要捕获<br>它可以无穷地迭代下去，每次数据都是实时产生的，不占用内存<br>（这不就是生成器吗！——）<br>虽然该迭代器是名副其实的数据生成器，但是生成器在python 中特指包含<code>yield</code> 的函数对象，以后会记录。<br>附:没有定义<code>__iter__</code>的可迭代对象<br>并不是所有的可迭代对象都必须定义<code>__iter__</code>方法<br>如果一个对象没有<code>__iter__</code>方法，但是定义了<code>__getitem__</code>方法，同样是可迭代的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DumbList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">if</span> index &gt; <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">return</span> index * <span class="number">2</span></span><br><span class="line">dl = DumbList()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> dl:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><br>因此，不能通过检查存在<code>__iter__</code> 方法来判断一个对象是否为可迭代的，而是应该直接使用<code>iter()</code>函数，如果不可迭代，则会抛出<code>TypeError</code>异常。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NotIterable</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">ni = NotIterable()</span><br><span class="line">it = <span class="built_in">iter</span>(ni)</span><br></pre></td></tr></table></figure></p>
<h3 id="1-7-生成器"><a href="#1-7-生成器" class="headerlink" title="1.7 生成器"></a>1.7 生成器</h3><h4 id="1-yield关键字"><a href="#1-yield关键字" class="headerlink" title="1.yield关键字"></a>1.yield关键字</h4><ul>
<li>只能用在函数内。</li>
<li>在函数的任何地方出现了<code>yield</code>关键字，哪怕永远无法被执行，函数都会发生变化。<br>这个变化就是当你以正常方式调用函数时，返回一个<code>生成器</code>对象，此时函数还没有运行。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">g = gen()</span><br><span class="line"><span class="built_in">print</span>(g)</span><br><span class="line"><span class="comment"># &lt;generator object at 0x0000...&gt;</span></span><br><span class="line"><span class="comment"># 未打印hello</span></span><br></pre></td></tr></table></figure>
<h4 id="2-术语解释"><a href="#2-术语解释" class="headerlink" title="2.术语解释"></a>2.术语解释</h4>通常我们把含有<code>yield</code>关键字的函数称为 生成器函数 generator function ，把调用生成器函数返回的结果称为 生成器。<br>但在python文档中：<blockquote>
<p>生成器 通常指的是生成器函数，但是在一定语境下也可以指代生成器迭代器 <code>generator iterator</code> ，为了避免歧义，推荐使用完整的术语。</p>
</blockquote>
</li>
</ul>
<p>既然叫做迭代器，那么我们可以理解 生成器对象就是一个迭代器。<br>从而满足 迭代器协议：</p>
<ul>
<li><code>__iter__</code>返回迭代器对象本身</li>
<li><code>__next__</code>返回一个迭代数据，如果没有数据，抛出<code>StopIteration</code>异常<h4 id="3-深入理解yield关键字"><a href="#3-深入理解yield关键字" class="headerlink" title="3.深入理解yield关键字"></a>3.深入理解yield关键字</h4><h5 id="语句or表达式"><a href="#语句or表达式" class="headerlink" title="语句or表达式"></a>语句or表达式</h5></li>
<li>yield 语句<ul>
<li>PEP252 — Simple Generator</li>
<li>Python 2.2</li>
</ul>
</li>
<li>yield 表达式<ul>
<li>PEP342 — Coroutines via Enhanced Generators</li>
<li>Python 2.5<h5 id="yield-对函数做了什么"><a href="#yield-对函数做了什么" class="headerlink" title="yield 对函数做了什么"></a>yield 对函数做了什么</h5><code>yield</code>关键字最根本作用是改变了函数的性质：</li>
</ul>
</li>
</ul>
<ol>
<li>调用生成器函数并不是直接执行其中的代码，而是返回一个对象。</li>
<li>生成器函数内的代码，需要通过生成器对象来执行。<br>从这一点，生成器函数的作用和 <code>类(class)</code>类似。<br>生成器对象就是迭代器，所以其运行方式和迭代器是一致的：</li>
</ol>
<ul>
<li>通过<code>next()</code> 函数来调用</li>
<li>每次<code>next()</code> 都会遇到<code>yield</code>后返回的结果（作为<code>next()</code>的返回值）</li>
<li>如果函数运行结束（即遇到<code>return</code>或代码执行完毕）则抛出<code>StopIteration</code>异常<br>示例<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个生成器函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="keyword">if</span> a:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"yield"</span>)</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">666</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"back"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"bye"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"result"</span></span><br><span class="line">g1 = gen(<span class="literal">False</span>) <span class="comment"># 不执行yield</span></span><br><span class="line">x = <span class="built_in">next</span>(g1)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">bye</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "D:\a.py", line 10, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    x = next(g1)</span></span><br><span class="line"><span class="string">StopIteration: result</span></span><br><span class="line"><span class="string">return 的结果也会被异常带出函数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">g2 = gen(<span class="literal">True</span>)</span><br><span class="line">y = <span class="built_in">next</span>(g2)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">yield</span></span><br><span class="line"><span class="string">666</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="built_in">next</span>(g2)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">back</span></span><br><span class="line"><span class="string">bye</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "D:\a.py", line 10, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    next(g2)</span></span><br><span class="line"><span class="string">StopIteration: result</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h5 id="在循环中使用-yield"><a href="#在循环中使用-yield" class="headerlink" title="在循环中使用 yield"></a>在循环中使用 yield</h5>只遇到一次<code>yield</code>语句的生成器就是只能迭代一次的迭代器，通常没什么价值<br>要想多迭代几次，可以在函数内多次使用<code>yield</code>语句：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
相对应的，<code>yield</code> 也可以搭配循环使用：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iterator count</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">start=<span class="number">0</span>, step=<span class="number">1</span></span>):</span><br><span class="line">    <span class="comment"># count(10) -&gt; 10 11 12...</span></span><br><span class="line">    <span class="comment"># count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...</span></span><br><span class="line">    n = start </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += step</span><br></pre></td></tr></table></figure>
<h5 id="生成的四个状态"><a href="#生成的四个状态" class="headerlink" title="生成的四个状态"></a>生成的四个状态</h5></li>
<li>当调用生成器函数得到生成器对象时<ul>
<li>此时的生成对象可以理解为<strong>初始</strong>状态</li>
</ul>
</li>
<li>通过<code>next()</code> 调用生成器对象，对应的生成器函数代码开始运行<ul>
<li>此时生成器对象处于<strong>运行中</strong>状态</li>
</ul>
</li>
<li>遇到<code>yield</code>语句，<code>next()</code>返回时<ul>
<li><code>yield</code>语句右边的对象作为<code>next()</code>的返回值</li>
<li>生成器在<code>yield</code>语句所在的位置<strong>暂停</strong>，当再次使用<code>next()</code>时继续在改位置运行</li>
</ul>
</li>
<li>如果执行到函数结束，则抛出<code>StopIteration</code>异常<ul>
<li>无论是使用了<code>return</code>语句显式地返回值，或者默认返回<code>None</code>值，返回值都只能作为异常的值一并抛出</li>
<li>此时生成器对象处于<strong>结束</strong>状态</li>
<li>对于已经结束的生成器对象再次调用<code>next()</code>，直接抛出<code>StopIteration</code>异常，并且不包含返回值<h5 id="使用yield重构迭代器"><a href="#使用yield重构迭代器" class="headerlink" title="使用yield重构迭代器"></a>使用yield重构迭代器</h5>与<code>class</code>定义迭代器对比</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>动作</th>
<th>class实现的迭代器</th>
<th>yield生成器</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义迭代器</td>
<td>class Iterator: def _<em>init_</em>(self, *args):</td>
<td>def iter(*args): …</td>
</tr>
<tr>
<td>构建迭代器</td>
<td>Iterator(args)</td>
<td>iter(args)</td>
</tr>
<tr>
<td>next(iterator)</td>
<td>def _<em>next_</em>(self): return values</td>
<td>yield value</td>
</tr>
<tr>
<td>StopIteration</td>
<td>raise StopIteration</td>
<td>return</td>
</tr>
<tr>
<td>iter(iterator)</td>
<td>def _<em>iter_</em>(self): return self</td>
<td>自动实现</td>
</tr>
</tbody>
</table>
</div>
<p>生成器的三种应用场景：</p>
<ul>
<li>定义一个容器类的对象，为该对象实现<code>__iter__</code>接口</li>
<li>定义一个处理其他可迭代对象的迭代器</li>
<li>定义一个不依赖数据存储的数据生成器<br>为数据列实现<code>__iter__()</code>接口</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustIter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="variable language_">self</span>.data = data</span><br><span class="line">        <span class="variable language_">self</span>.index = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.index = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.index &lt; <span class="variable language_">self</span>.data.size:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.data.get_value(<span class="variable language_">self</span>.index)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"><span class="comment"># 可迭代数据类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustData</span>:</span><br><span class="line">    <span class="comment"># 其余部分代码不重要 略</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>): <span class="comment"># 假设可以得到数据的大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_value</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> CustIter(<span class="variable language_">self</span>)</span><br></pre></td></tr></table></figure>
<p>yield 重构<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除CustIter类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustData</span>:</span><br><span class="line">    <span class="comment"># 其余部分代码不重要 略</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>): <span class="comment"># 假设可以得到数据的大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.size</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_value</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        index = -<span class="number">1</span>      <span class="comment"># 必须是局部变量</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; <span class="number">2</span>: <span class="comment"># 设置迭代完成的条件</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">yield</span> <span class="variable language_">self</span>.get_value(index)</span><br><span class="line"> mydata = CustData() <span class="comment"># 注  mydata 是可迭代对象，但不是迭代器</span></span><br></pre></td></tr></table></figure><br>实现有处理数据功能的迭代器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BLACK_LIST = [<span class="string">"1"</span>, <span class="string">"2"</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataFilter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, actions</span>):</span><br><span class="line">        <span class="variable language_">self</span>.actions = actions</span><br><span class="line">        <span class="variable language_">self</span>.index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.index &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>.actions):</span><br><span class="line">            action = <span class="variable language_">self</span>.actions[<span class="variable language_">self</span>.index]</span><br><span class="line">            <span class="variable language_">self</span>.index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> action <span class="keyword">in</span> BLACK_LIST:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="string">"3"</span> <span class="keyword">in</span> action:</span><br><span class="line">                <span class="keyword">return</span> action * <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> action</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br></pre></td></tr></table></figure><br>yield重构<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BLACK_LIST = [<span class="string">"1"</span>, <span class="string">"2"</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">filt</span>(<span class="params">actions</span>):</span><br><span class="line">    <span class="keyword">for</span> action <span class="keyword">in</span> actions:</span><br><span class="line">        <span class="keyword">if</span> action <span class="keyword">in</span> BLACK_LIST:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">"3"</span> <span class="keyword">in</span> action:</span><br><span class="line">            <span class="keyword">yield</span> action * <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> action</span><br><span class="line">actions = [<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> filt(actions):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><br>实现一个数据生成器<br>计数器实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start</span>):</span><br><span class="line">        <span class="variable language_">self</span>.start = start</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.start &gt; <span class="number">0</span>:</span><br><span class="line">            start -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.start</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br></pre></td></tr></table></figure>
<p>yield重构<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">start</span>):</span><br><span class="line">    <span class="keyword">while</span> start &gt; <span class="number">0</span>:</span><br><span class="line">        start -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> start</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> count(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></p>
<h5 id="重要-生成器技术实现"><a href="#重要-生成器技术实现" class="headerlink" title="(重要) 生成器技术实现"></a>(重要) 生成器技术实现</h5><p>主要内容</p>
<ul>
<li>生成器函数和普通函数的区别</li>
<li>生成器对象和生成器函数之间的关系</li>
<li>生成器函数可以<em>暂停</em>执行的秘密<br><strong>普通函数的运行机制</strong><br>函数对象和代码对象<br>每当定义了一个函数之后，就得到了一个 函数对象：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    ...</span><br><span class="line"><span class="built_in">print</span>(func)</span><br><span class="line"><span class="comment"># &lt;function __main__.func()&gt;</span></span><br></pre></td></tr></table></figure>
函数中的代码是保存在 <strong>代码对象 Code Object</strong> 中的：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(func.__code__)</span><br><span class="line"><span class="comment"># &lt;code object func at 0x..., file "&lt;...&gt;", line 1&gt;</span></span><br></pre></td></tr></table></figure>
代码对象会随着函数对象一起创建，是函数对象的一个重要属性。</li>
</ul>
<blockquote>
<p>Code objects represent byte-compiled executable Python code, or byte code</p>
</blockquote>
<p>代码对象中重要的属性以<code>co_</code>开头：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func_code = func.__code__</span><br><span class="line"><span class="keyword">for</span> attr <span class="keyword">in</span> <span class="built_in">dir</span>(func_code):</span><br><span class="line">    <span class="keyword">if</span> attr.starstwith(<span class="string">"co_"</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"<span class="subst">{attr}</span>\t: <span class="subst">{<span class="built_in">getattr</span>(func_code, attr)}</span>"</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">co_argcount     : 0</span></span><br><span class="line"><span class="string">co_cellvars     : ()</span></span><br><span class="line"><span class="string">co_code : b'd\x00S\x00'</span></span><br><span class="line"><span class="string">co_consts       : (None,)</span></span><br><span class="line"><span class="string">co_filename     : &lt;ipython-input-1-4152f59160a0&gt;</span></span><br><span class="line"><span class="string">co_firstlineno  : 1</span></span><br><span class="line"><span class="string">co_flags        : 67</span></span><br><span class="line"><span class="string">co_freevars     : ()</span></span><br><span class="line"><span class="string">co_kwonlyargcount       : 0</span></span><br><span class="line"><span class="string">co_lines        : &lt;built-in method co_lines of code object at 0x000001F0961F68C0&gt;</span></span><br><span class="line"><span class="string">co_linetable    : b'\x04\x01'</span></span><br><span class="line"><span class="string">co_lnotab       : b'\x00\x01'</span></span><br><span class="line"><span class="string">co_name : func</span></span><br><span class="line"><span class="string">co_names        : ()</span></span><br><span class="line"><span class="string">co_nlocals      : 0</span></span><br><span class="line"><span class="string">co_posonlyargcount      : 0</span></span><br><span class="line"><span class="string">co_stacksize    : 1</span></span><br><span class="line"><span class="string">co_varnames     : ()</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><br><strong>函数运行帧</strong><br>函数对象和代码对象保存了函数的基本信息，当函数运行时，还需要一个对象来保存运行状态。<br>这个对象就是<strong>帧对象（Frame Object）</strong></p>
<blockquote>
<p>Frame objects represent execution frames.</p>
</blockquote>
<p>每次调用一个函数，都会创建帧对象，来记录每次运行的状态。<br>使用<code>inspect</code>检查帧对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="comment"># 获取到函数的运行帧并返回</span></span><br><span class="line">    <span class="comment"># 通常情况下 函数运行帧 在函数运行结束后会被立即销毁</span></span><br><span class="line">    <span class="keyword">return</span> inspect.currentframe()</span><br><span class="line">f1 = foo() <span class="comment"># 但由于变量被引用，所以帧不会被垃圾回收</span></span><br><span class="line"><span class="built_in">print</span>(f1)</span><br><span class="line"><span class="comment"># &lt;frame at 0x..., file '...', line 5, code foo&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jupyter 运行此代码 导入 import objgraph</span></span><br><span class="line"><span class="comment"># 再调用一次，获取另一个帧</span></span><br><span class="line">f2 = foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数对象、代码对象和帧对象之间的关系</span></span><br><span class="line">objgraph.show_backrefs(foo.__code__)</span><br></pre></td></tr></table></figure>
<p>可见 <code>function</code> 和 <code>frame</code>对象均有对<code>code</code>的引用。<br>帧对象中重要的属性以<code>f_</code>开头：</p>
<ul>
<li><code>f_code</code>：执行的代码对象</li>
<li><code>f_back</code>: 指向上一个帧，也就是调用者的帧</li>
<li><code>f_locals</code>: 局部变量</li>
<li><code>f_globals</code>: 全局变量</li>
<li><code>f_lineno</code> ：当前对应的行号<br><strong>函数运行栈</strong><br>当一个函数调用了另一个函数，此时前一个函数还没有结束，所以这两个函数的帧对象是同时存在的。<br>比如，我们的程序一般始于一个<code>main</code>函数，然后又调用其他函数，以此类推。<br>因此，一个程序的运行期，同时存在很多个帧对象。<br>函数之间的调用关系是<strong>先执行的后退出</strong>，所以帧对象之间的关系也是<strong>先入后出</strong>，正好以<strong>栈</strong>的方式保存。<br>因此，函数的运行帧又叫<strong>栈帧</strong>。<br>注：一个线程只有一个函数的运行栈。<blockquote>
<p>观察此过程，可以安装vscode的python preview模块</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 展示发生函数调用时的栈</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> inspect.currentframe()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">return</span> foo() <span class="comment"># 返回foo函数运行时的帧对象</span></span><br><span class="line">f1 = bar()</span><br><span class="line">objgraph.show_refs(f1)</span><br></pre></td></tr></table></figure>
<p><img src="image-20220606035431001.png" alt="image-20220606035431001"></p>
<p><strong>生成器函数有何不同</strong><br>生成器函数依然是函数对象，当然也包括了代码对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_foo</span>():</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">yield</span> inspect.currentframe() <span class="comment"># 每一次迭代都返回当前帧</span></span><br></pre></td></tr></table></figure><br>调用生成器函数不会直接运行（也就是说，不像普通函数那样创建帧对象并且压入函数栈），而是得到一个生成器对象。<br>那么秘密自然在生成器对象里：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gf = gen_foo()</span><br><span class="line">show_refs(gf)</span><br></pre></td></tr></table></figure></p>
<p><img src="image-20220606040112014.png" alt=""><br>当每次使用<code>next()</code>对生成器进行迭代时，都用这个帧对象<code>gi_frame</code>来保存状态：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 展示生成器迭代过程中都是同一个frame对象</span></span><br><span class="line">gf = gen_foo()</span><br><span class="line"><span class="comment"># 存为变量，不然迭代结束属性会清空</span></span><br><span class="line">gi_frame = gf.gi_frame</span><br><span class="line"><span class="comment"># 保存所有迭代结果</span></span><br><span class="line">frames = <span class="built_in">list</span>(gf)</span><br><span class="line"><span class="built_in">print</span>(gf.gi_frame) <span class="comment"># None</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> frames:</span><br><span class="line">    <span class="built_in">print</span>(f <span class="keyword">is</span> gi_frame)</span><br><span class="line"><span class="comment"># True * 10</span></span><br></pre></td></tr></table></figure>
<p>生成器的frame对象在暂停状态下看不到调用关系图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gf = gen_foo()</span><br><span class="line"><span class="comment"># f = next(gf)</span></span><br><span class="line">show_refs(gf.gi_frame) <span class="comment"># 当执行到此 函数执行结束 函数帧已经出栈</span></span><br></pre></td></tr></table></figure>
<p><img src="image-20220606040816751.png" alt="image-20220606040816751"></p>
<p>观察生成器运行时运行栈的关系图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen_frame_graph</span>():</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="comment"># 运行时生成图形</span></span><br><span class="line">        graph = show_refs(inspect.currentframe())</span><br><span class="line">        <span class="keyword">yield</span> graph</span><br><span class="line">gfg = gen_frame_graph()</span><br><span class="line"><span class="comment"># 定义两个不同名的函数是为了方便观察栈的变化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_a</span>(<span class="params">g</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">next</span>(g)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_b</span>(<span class="params">g</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">next</span>(g)</span><br><span class="line">func_a(gfg)</span><br></pre></td></tr></table></figure></p>
<p><img src="image-20220606041431193.png" alt="image-20220606041431193"><br>综上总结：</p>
<ul>
<li>生成器函数并不直接运行，而是借助生成器对象来间接运行</li>
<li>创建生成器对象的同时创建了帧对象，并且由生成器对象保持引用</li>
<li>每次使用<code>next()</code>调用生成器时，就是将生成器引用的帧对象入栈</li>
<li>当<code>next()</code>返回时，也就是代码遇到<code>yield</code>暂停的时候，就是将帧出栈</li>
<li>知道迭代结束，帧最后一次出栈，并且被销毁<br><strong>同步和异步的概念</strong><br>普通函数：</li>
<li>调用函数：构建帧对象并入栈</li>
<li>函数执行结束：帧对象出栈并销毁</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通函数只能以同步方式运行多任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sync_task_runner</span>():</span><br><span class="line">    task_a()</span><br><span class="line">    task_b() <span class="comment"># 等到task_a执行结束才会运行</span></span><br></pre></td></tr></table></figure>
<p>生成器函数：</p>
<ul>
<li>创建生成器： 构建帧对象</li>
<li>（多次）通过<code>next()</code>出发执行：帧入栈</li>
<li>（多次）通过<code>yield</code>帧出栈（保留）</li>
<li>迭代结束：帧出栈并销毁<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成器函数让异步称为可能</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">async_task</span>():</span><br><span class="line">    <span class="comment"># step 1</span></span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="comment"># step 2</span></span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="comment"># step 3</span></span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line"><span class="comment"># 任务队列</span></span><br><span class="line">all_tasks = []</span><br><span class="line"><span class="comment"># 创建两个任务</span></span><br><span class="line">async_task_a = async_task()</span><br><span class="line">async_task_b = async_task()</span><br><span class="line"><span class="comment"># 加入任务队列</span></span><br><span class="line">all_tasks.append(asnc_task_a)</span><br><span class="line">all_tasks.append(asnc_task_b)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">async_task_runner</span>():</span><br><span class="line">    <span class="comment"># 简易异步任务调度器</span></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> all_tasks:</span><br><span class="line">        <span class="built_in">next</span>(task)</span><br></pre></td></tr></table></figure>
<img src="image-20220606043055017.png" alt="image-20220606043055017"><br><strong>从生成器到协程</strong><br>现在，我们可以更好地理解所谓的<code>generator iterator</code>是什么了：<blockquote>
<p>生成器对象是一个用来迭代执行生成器函数的迭代器</p>
</blockquote>
</li>
<li>数据的迭代器：针对一个包含很多元素的数据集，逐个返回其中的元素</li>
<li>生成器迭代器：针对一个包含很多代码的函数，分段执行其中的代码<br>让一个函数多次迭代运行其中的代码才是生成器对象最根本的作用，而不仅是字面意义上的<em>生成数据的东西</em><br>迭代产生数据只是迭代器执行代码的自然结果。<br>当用生成器来实现迭代器的时候，我们更加关注<code>yield &lt;value&gt;</code>返回出的数据。<br>如果关注点在<strong>被迭代执行的代码上</strong>，就能对生成器有个全新的认识，就是<strong>协程</strong>。 <h5 id="协程（yield）"><a href="#协程（yield）" class="headerlink" title="协程（yield）"></a>协程（yield）</h5>基于生成器的协程</li>
</ul>
<blockquote>
<p>Generator-based Coroutines</p>
<p>Deprecated since version 3.8, will be removed in version 3.11: Use <code>async def</code>instead.</p>
</blockquote>
<p>对比 generator 和 coroutine<br>虽然py有了新的语法，但是他只是增加了一个原生的<code>coroutine</code>类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成器版协程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generator_func</span>():</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">gen = generator_func()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(gen)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(<span class="built_in">set</span>(<span class="built_in">dir</span>(gen)) - <span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="built_in">object</span>))))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;generator object generator_func at 0x0000029945CE4740&gt;</span></span><br><span class="line"><span class="string">['__del__', '__iter__', '__name__', '__next__', '__qualname__', 'close', 'gi_code', 'gi_frame', 'gi_running', 'gi_yieldfrom', 'send', 'throw']</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新版协程</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">coroutine_func</span>():</span><br><span class="line">    <span class="keyword">await</span> coroutine_func()</span><br><span class="line">coro = coroutine_func()</span><br><span class="line"><span class="built_in">print</span>(coro)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(<span class="built_in">set</span>(<span class="built_in">dir</span>(coro)) - <span class="built_in">set</span>(<span class="built_in">dir</span>(<span class="built_in">object</span>))))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;coroutine object coroutine_func at 0x00000299478B1FC0&gt;</span></span><br><span class="line"><span class="string">['__await__', '__del__', '__name__', '__qualname__', 'close', 'cr_await', 'cr_code', 'cr_frame', 'cr_origin', 'cr_running', 'send', 'throw']</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>这俩完全一样，除了<code>__next__</code>被去掉，因为协程不需要迭代。<br><code>__iter__</code>换成了<code>__await_</code><br><code>gi_yieldfrom</code>换成了<code>cr_await</code><br>为了更好理解和学习协程，有必要了解两者关系及不同。<br><strong>生成器的增强点</strong><br>前面提到过生成器最大的改变点就是yield语句升级为了yield表达式<a href="#####yield 对函数做了什么">见yield对函数做了什么</a><br>所谓<strong>表达式（Expression）</strong>，意味着他可以被解析成一个<strong>值</strong>，然后赋值给变量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">yield</span></span><br><span class="line"><span class="comment"># 计算后赋值</span></span><br><span class="line">x = <span class="keyword">yield</span> + <span class="number">1</span></span><br><span class="line"><span class="comment"># 表达式 作为函数参数 但是需要使用()</span></span><br><span class="line"><span class="built_in">print</span>((<span class="keyword">yield</span>))</span><br><span class="line"><span class="comment"># 以上 yield 表达式均不能用在函数外面</span></span><br></pre></td></tr></table></figure></p>
<p><strong><code>yield</code>表达式如何获取到值？</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_yield_value</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"开始"</span>)</span><br><span class="line">    x = <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"x is <span class="subst">{x}</span>"</span>)</span><br><span class="line">g = show_yield_value()</span><br><span class="line"><span class="built_in">next</span>(g) <span class="comment"># 第一次</span></span><br><span class="line"><span class="built_in">next</span>(g) <span class="comment"># 第二次</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">x is None</span></span><br><span class="line"><span class="string">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">StopIteration                             Traceback (most recent call last)</span></span><br><span class="line"><span class="string">Input In [8], in &lt;cell line: 1&gt;()</span></span><br><span class="line"><span class="string">----&gt; 1 next(g)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">StopIteration:</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>next()</code>函数来驱动生成器时，<code>yield</code>表达式的值总为<code>None</code>。<br>为生成器增加一个<code>send()</code>方法，改方法可以接受一个参数。<br><code>send</code>方法顾名思义，将改参数发送给生成器，时生成器恢复运行的同时，将该入参作为<strong>yield表达式</strong>的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 还是上面的生成器函数</span></span><br><span class="line">g = show_yield_value()</span><br><span class="line">g.send(<span class="string">"hello"</span>) <span class="comment"># 第一次只能是None</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">TypeError                                 Traceback (most recent call last)</span></span><br><span class="line"><span class="string">Input In [13], in &lt;cell line: 1&gt;()</span></span><br><span class="line"><span class="string">----&gt; 1 g.send("hell")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TypeError: can't send non-None value to a just-started generator</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后 </span></span><br><span class="line">g.send(<span class="literal">None</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">开始</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">g.send(<span class="string">"hello"</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">x is hello</span></span><br><span class="line"><span class="string">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">StopIteration                             Traceback (most recent call last)</span></span><br><span class="line"><span class="string">Input In [8], in &lt;cell line: 1&gt;()</span></span><br><span class="line"><span class="string">----&gt; 1 g.send("hello")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">StopIteration:</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p><strong>关于prime</strong><br>对于刚刚创建好的生成器，总是需要<code>send(None)</code>，使其运行到<code>yield</code>上方暂停，这个步骤称为<code>prime</code>。</p>
<blockquote>
<p>这里prime做动词意思：PREPARE SOMEBODY to prepare someone for a situation so that they know what to do. 使某些人、东西准备好应付某个情况。</p>
<p>prime在《流畅的python》中文版被翻译为 <strong>预激</strong> ，感觉过于专业拗口，其实这个步骤后续没有那么重要（后面会解释），所以我就直接称为 <strong>激活</strong> 。</p>
<p>最先调用next(my_coro)函数这一步通常称为“预激”（prime）协程（即，让协程向前执行到第一个yield表达式，准备好作为活跃的协程使用）。</p>
</blockquote>
<p><strong>yield表达式的优先级</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_yield_value</span>():</span><br><span class="line">    x = <span class="keyword">yield</span> + <span class="number">1</span> <span class="comment"># error</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f'x is <span class="subst">{x}</span>'</span>)</span><br><span class="line">g = add_yield_value()</span><br><span class="line">g.send(<span class="literal">None</span>) <span class="comment"># prime</span></span><br><span class="line"><span class="comment"># 输出了一个1</span></span><br><span class="line">g.send(<span class="number">1</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">x is 1</span></span><br><span class="line"><span class="string">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">StopIteration                             Traceback (most recent call last)</span></span><br><span class="line"><span class="string">Input In [8], in &lt;cell line: 1&gt;()</span></span><br><span class="line"><span class="string">----&gt; 1 g.send(1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">StopIteration:</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 出现此错误的原因大概是因为yield仍然具有作为yield语句的功能 将其后面的对象返回出来</span></span><br><span class="line"><span class="comment"># yield + 1 等价于 (yield +1) +号相当于是一个正号 所以第一次send返回1</span></span><br><span class="line"><span class="comment"># 要想得到预期结果 改为(yield) + 1</span></span><br></pre></td></tr></table></figure>
<p>yield表达式优先级比较低，要想实现相应的功能尽可能地给yield加括号 提高优先级。<br><strong>send总结</strong></p>
<ul>
<li><code>send</code>是生成器对象的方法</li>
<li>对于生成器对象<code>g</code>，<code>next(g)</code> 等价于 <code>g.send(None)</code></li>
<li>只有当生成器处在<strong>暂停</strong>状态时，才能传入非None值</li>
<li><code>send</code>方法是为了协程而增加的api，所以：<ul>
<li>如果将生成器视作协程，就应该只用<code>sned</code>方法</li>
<li>如果视作迭代器，就仍用<code>next</code><br>所以，后面我们统一使用<code>g.send(None)</code>方式。<br>简单的echo示例</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen_echo</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>((<span class="keyword">yield</span>))</span><br><span class="line">echo = gen_echo()</span><br><span class="line">echo.send(<span class="literal">None</span>) <span class="comment"># prime</span></span><br><span class="line">echo.send(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 如何结束这个服务</span></span><br><span class="line"><span class="comment"># 传入StopIteration?</span></span><br><span class="line"><span class="comment"># 事实上不行</span></span><br></pre></td></tr></table></figure>
<p><strong>使用<code>close()</code>结束生成器</strong><br>当生成器作为迭代器来用的时候，他的生命周期取决于有多少元素可以迭代。<br>当作为协程来用的时候，通常可以视作在执行一个任务，我们希望任务的终止变得可控。<br>新增的<code>close</code>方法就是用来结束一个协程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">echo.close()</span><br><span class="line">echo.send(<span class="string">"hi"</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">---------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">StopIteration                             Traceback (most recent call last)</span></span><br><span class="line"><span class="string">Input In [17], in &lt;cell line: 1&gt;()</span></span><br><span class="line"><span class="string">----&gt; 1 echo.send("hi")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">StopIteration:</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>由于echo协程非常简单，所以他可以直接结束。<br>如果协程代码比较复杂，他可能需要在结束的时候做一些善后处理，比如释放资源等。<br>类似于<code>StopIteration</code>的实现机制，结束协程也是靠异常来实现的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen_echo_v2</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            x = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">except</span> GeneratorExit: <span class="comment"># 协程也叫这个</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"exit"</span>) <span class="comment"># 做善后处理</span></span><br><span class="line">            <span class="keyword">return</span>      <span class="comment"># 必须要结束函数 break 同理 如果没有进行此操作 回到yield 则运行时错误</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo_v2 = gen_echo_v2()</span><br><span class="line">echo_v2.send(<span class="literal">None</span>)  <span class="comment"># 既然有try yield 那么在激活后才能捕获异常 </span></span><br><span class="line">echo_v2.close() <span class="comment"># 没有 激活也可以close 但是什么都没有发生</span></span><br></pre></td></tr></table></figure>
<p>除了显式地调用<code>close</code>方法，如果生成器对象被垃圾回收，也会自动调用<code>close</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例如</span></span><br><span class="line"><span class="keyword">del</span> echo_v2 </span><br><span class="line"><span class="comment"># 或者 重新赋值 都会出发close</span></span><br><span class="line">echo_v2 = <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p><strong>使用<code>throw()</code>将异常抛给<code>yield</code></strong><br>类似<code>close()</code> 只是它是固定的<code>GeneratorExit</code>类型，而throw是任意的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen_echo_v3</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            x = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">except</span> GeneratorExit:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"exit"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Ctrl c"</span>) <span class="comment"># 其他异常没有硬性要求退出 可以不return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo_v3 = gen_echo_v3()</span><br><span class="line">echo_v3.send(<span class="literal">None</span>) <span class="comment"># prime</span></span><br><span class="line">echo_v3.throw(KeyboardInterrupt)</span><br><span class="line">echo_v3.throw(RuntimeError) <span class="comment"># 如果传入了没有处理的异常则直接抛出到调用部分 也会造成生成器退出</span></span><br></pre></td></tr></table></figure>
<p><strong>协程的几个功能点</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例子来自《流畅的python》</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coro_averager</span>():</span><br><span class="line">    <span class="comment"># 计算移动平均值</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    avg = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            val = <span class="keyword">yield</span> avg</span><br><span class="line">        <span class="keyword">except</span> GeneratorExit:</span><br><span class="line">            <span class="keyword">return</span> total, count, avg</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            total += val</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            avg = total/count</span><br></pre></td></tr></table></figure>
<ol>
<li>在<code>yield</code>位置产出数据</li>
<li>在<code>yield</code>位置暂停</li>
<li>在<code>yield</code>位置恢复，并接收新的参数</li>
<li>在<code>yield</code>位置传入结束信号</li>
<li>在<code>yield</code>位置传入其他异常<h5 id="yield三种用法"><a href="#yield三种用法" class="headerlink" title="yield三种用法"></a>yield三种用法</h5><strong>基于生成器的协程 概念</strong><br>按照Python 文档的描述，所谓的 <em>基于生成器的协程</em> 指的是用<code>yield from</code>创建的生成器，并且还要搭配<code>asyncio.corotine</code>装饰器来使用。<br><strong>生成器的三种模式</strong><br>来自龟叔的解释<br>Python之父Guido在一封邮件里总结道，生成器有三种模式：</li>
</ol>
<blockquote>
<p>There’s the traditional “pull” style (iterators), “push” style (like the averaging example),</p>
<p>and then there are “tasks”.</p>
</blockquote>
<ul>
<li>pull 特点在于能不断向外产出数据，也就是迭代器</li>
<li>push 特点在于能不断向内发送数据，比如上一章中的计算平均移动的例子，是非常早的协程概念</li>
<li>task 任务式 (Asyncio里的协程)</li>
</ul>
<p><img src="image-20220608184437822.png" alt="image-20220608184437822"><br><img src="image-20220608184532997.png" alt="image-20220608184532997"><br><strong>data vs event </strong><br>一句话解释是：</p>
<ul>
<li>pull/push 都是受<strong>数据驱动</strong>的</li>
<li><p>task是受<strong>事件</strong>驱动的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pull 风格的生成器伪代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pull_style</span>():</span><br><span class="line">    <span class="keyword">while</span> still_have_data:</span><br><span class="line">        <span class="keyword">yield</span> data</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># push 伪代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push_style</span>():</span><br><span class="line">    <span class="keyword">while</span> still_have_data:</span><br><span class="line">        input_data = <span class="keyword">yield</span> output_data</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># task 生成器 协程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task_style</span>():</span><br><span class="line">    ??? = <span class="keyword">yield</span> ???</span><br></pre></td></tr></table></figure>
<p><strong>什么是event?</strong><br>事件（event）是个抽象的概念，就是指一件事情发生了。<br>例如：<br>要休息3秒 钟后继续执行， 3秒时间到，这就是一个事件。<br>再例如：<br>要读取网络数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.recv(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure>
<p>如果socket还没收到数据，此时这个调用就会阻塞，知道有数据可读。socket<strong>变得可读</strong>，这就是一个事件。<br><strong>event是如何运作的</strong><br>事件通常是通过<strong>回调函数（callback）</strong>来处理的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置回调函数</span></span><br><span class="line"><span class="comment"># 3s后调用func</span></span><br><span class="line">call_later(<span class="number">3</span>, func)</span><br><span class="line"><span class="comment"># 当socker 可读时调用read</span></span><br><span class="line">register(sock, selectors.EVENT_READ, read)</span><br></pre></td></tr></table></figure>
</li>
<li><p>那为什么要让出<code>yield</code>执行权（也就是出栈）？</p>
<ul>
<li>遇到什么样的事件需要<code>yield</code>？</li>
<li>在出栈前该如何设置事件（回调）？</li>
</ul>
</li>
<li>凭什么能恢复执行（入栈）？<ul>
<li>是谁促成了事件的发生？</li>
<li>是谁（感知了事件的发生）让出栈的协程再次入栈（也就是说，谁来调用<code>send</code>）？<br>既然协程不需要写回调函数，那这些是怎么回事？<h5 id="协程（yield-from"><a href="#协程（yield-from" class="headerlink" title="协程（yield from)"></a>协程（yield from)</h5>入门例子<br>绝大多数及教程，包括《流畅的python》这本书中，关于<code>yield from</code>的基础例子非常糟糕。<br>基本上是以一个<code>for</code>开场。<br>然后各种新术语安排上，什么委派生成器，子生成器等。。<br>这些难免让人迷惑，费这么大力气就是为了少些一层循环？<br><strong>语法</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RESULT = <span class="keyword">yield</span> <span class="keyword">from</span> EXPR <span class="comment"># 表达式的值必须是一个可迭代对象</span></span><br></pre></td></tr></table></figure>
<p>例子<br><img src="image-20220608191502801.png" alt="image-20220608191502801"></p>
<p>继续简化<br><img src="image-20220608191754919.png" alt="image-20220608191754919"><br>再简化<br><img src="image-20220608191917826.png" alt="image-20220608191917826"></p>
<p><strong>定义一个同步模式的简单任务</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">one_task</span>():</span><br><span class="line">    <span class="comment"># 一个任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'big task'</span>)</span><br><span class="line">    ... <span class="comment"># 其他步骤</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'begin big_step'</span>)</span><br><span class="line">    big_result = big_step()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f'end big_step with <span class="subst">{big_result}</span>'</span>)</span><br><span class="line">    ... <span class="comment"># 其他步骤</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'end task'</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">big_step</span>():</span><br><span class="line">    ... <span class="comment"># 其他小步骤</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'begin small step'</span>)</span><br><span class="line">    small_result = small_step()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f'end small step with <span class="subst">{small_step}</span>'</span>)</span><br><span class="line">    ... <span class="comment"># 其他小步骤</span></span><br><span class="line">    <span class="keyword">return</span> small_result * <span class="number">1000</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_step</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'working..'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span> <span class="comment"># 完成</span></span><br><span class="line">one_task()  <span class="comment"># 执行任务</span></span><br></pre></td></tr></table></figure>
<p>当小步骤遇到阻塞</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_step</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'working...'</span>)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"done"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>可以通过yield创建协程 阻塞由下游传染至上游</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># small step </span></span><br><span class="line"><span class="keyword">yield</span> sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># big_step</span></span><br><span class="line">small_coro = small_step()</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">    	x = small_coro.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        small_result = e.value</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>yield 可以正常运行，但阻塞问题仍然没有解决</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># small step</span></span><br><span class="line"><span class="keyword">yield</span> sleep,<span class="number">2</span> <span class="comment"># 不在这里调用 传染至 else:</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">except</span> ...:</span><br><span class="line">  	...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># pass</span></span><br><span class="line">    <span class="keyword">yield</span> x <span class="comment"># 传染至one_task</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># one_task</span></span><br><span class="line"><span class="comment"># big_result = big_step()</span></span><br><span class="line">big_coro = big_step()</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">    	x = big_coro.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        big_result = e.value</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        func, arg = x <span class="comment"># 传出的是sleep 2</span></span><br><span class="line">        func(arg) <span class="comment"># 调用sleep(2)</span></span><br></pre></td></tr></table></figure>
<p><strong>改用yield from </strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># big_step</span></span><br><span class="line">small_result = <span class="keyword">yield</span> <span class="keyword">from</span> small_step() <span class="comment">#  正常运行</span></span><br></pre></td></tr></table></figure>
<p><strong>统一使用yield from</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># small_step </span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">from</span> (sleep, <span class="number">2</span>) <span class="comment"># 错误，相当于yield 一次 sleep 又一次 2 yield from 首先要调用iter(EXPR)</span></span><br><span class="line"><span class="comment"># 问题出在 func, arg = x</span></span><br><span class="line"><span class="comment"># TypeError cannot unpack non-iterable built_in_function_or_method object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所以 定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YieldFrom</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="variable language_">self</span>.obj = obj</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">yield</span>  <span class="variable language_">self</span>.obj</span><br><span class="line"><span class="comment"># 改为</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">from</span> YieldFrom((sleep, <span class="number">2</span>)) <span class="comment"># 传入元组</span></span><br></pre></td></tr></table></figure>
<p>又正常了</p>
<p><strong>将任务彻底协程化</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># one_task</span></span><br><span class="line"><span class="comment"># big_coro = big_step()</span></span><br><span class="line"><span class="comment"># while 1:</span></span><br><span class="line"><span class="comment"># 		...</span></span><br><span class="line"><span class="comment"># 改为</span></span><br><span class="line">big_result = <span class="keyword">yield</span> <span class="keyword">from</span> big_step()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用</span></span><br><span class="line">one_task()</span><br><span class="line"><span class="comment"># &lt;generator object one_task at 0x... &gt;</span></span><br><span class="line"><span class="comment"># 这样任务就会会返回一个生成器 无法运行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个通用任务驱动器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, coro</span>):</span><br><span class="line">        <span class="variable language_">self</span>.coro = coro</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    		<span class="keyword">try</span>:</span><br><span class="line">    			x = <span class="variable language_">self</span>.coro.send(<span class="literal">None</span>)</span><br><span class="line">    		<span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        		result = e.value</span><br><span class="line">        		<span class="keyword">break</span></span><br><span class="line">    		<span class="keyword">else</span>:</span><br><span class="line">        		func, arg = x</span><br><span class="line">        		func(arg)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行</span></span><br><span class="line">t = Task(one_task())</span><br></pre></td></tr></table></figure>
<p>但是 此时的兼容性并不好</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    func, arg = x</span><br><span class="line">    func(arg)</span><br></pre></td></tr></table></figure>
<p>找到YielfFrom类，修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># yield self.value</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="variable language_">self</span></span><br></pre></td></tr></table></figure>
<p>Task 类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(x, YieldFrom)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>我们来看最终代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YieldFrom</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = obj</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="variable language_">self</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, coro</span>):</span><br><span class="line">        <span class="variable language_">self</span>.coro = coro</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                x = <span class="variable language_">self</span>.coro.send(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">                result = e.value</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">isinstance</span>(x, YieldFrom)</span><br><span class="line">                func, arg = x.value</span><br><span class="line">                func(arg)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_step</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"working.."</span>)</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> YieldFrom((sleep, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">assert</span> time.time() - t1 &gt; <span class="number">2</span>, <span class="string">'时间不足'</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"working ..."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">big_step</span>():</span><br><span class="line">    ... <span class="comment"># 小步骤</span></span><br><span class="line">    small_result = <span class="keyword">yield</span> <span class="keyword">from</span> small_step()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"small step end with <span class="subst">{small_result}</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> small_result * <span class="number">1888</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">one_task</span>():</span><br><span class="line">    <span class="comment"># 一个任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"start task"</span>)</span><br><span class="line">    ... <span class="comment"># 其他步骤</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"begin big step"</span>)</span><br><span class="line">    big_result = <span class="keyword">yield</span> <span class="keyword">from</span> big_step()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'endbigstep'</span>)</span><br><span class="line">    ... <span class="comment"># 其他步骤</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'end task'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t = Task(one_task())</span><br><span class="line">    t.run()</span><br></pre></td></tr></table></figure>
<p>升级为新的语法</p>
<ol>
<li>首先将其中所有的 <code>yield from</code>替换成<code>await</code></li>
<li><code>__iter__</code>替换 为 <code>__await__</code></li>
<li>包含<code>await</code>的函数改为<code>async def</code></li>
</ol>
<p>两次程序结果一模一样</p>
<p>两个程序的对比</p>
<p>使用<code>yield from</code>生成的函数成为<code>generator function</code> 执行的结果称为<code>generator</code></p>
<p>使用<code>await</code>生成的函数称为<code>coroutine function</code>执行的结果称为<code>corotine</code></p>
<p>我们将<code>corotine</code>的协程称为<code>native corotine</code>, <code>generator</code>的协程称为<code>generator based corotine</code></p>
<p>既然都已经升级为新语法了 我们可以把<code>YieldFrom</code>这个类改为<code>awaitable</code></p>
<p>那么什么是<code>awaitable</code>呢</p>
<p>这个概念分为两种，一种是我们在上面定义的<code>corotine</code>，另外一种就是我们在<code>class Awaitable</code>定义的<code>__await__</code>方法</p>
<p>这两种都可以跟在<code>await</code>关键字后面。</p>
<p>在<code>asyncio</code>里有两种<code>class</code>也是<code>awaitable</code>的，一个是<code>Task</code>一个是<code>Future</code>，更为准确的说是一个，<code>Future</code>，因为<code>Task</code>实际上是继承<code>Future</code></p>
<p>在<code>Future</code>相关的代码里</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__await__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.done():</span><br><span class="line">        <span class="variable language_">self</span>._asyncio_future_blocking ...</span><br><span class="line">        <span class="keyword">yield</span> <span class="variable language_">self</span></span><br><span class="line">        ...</span><br><span class="line">__iter__ = __await__ <span class="comment"># 兼容 yield from</span></span><br></pre></td></tr></table></figure>
<p><code>yield self</code>非常关键，可以说在<code>asyncio</code>里面只有在这个地方才能找到<code>yield</code></p>
<p>在前文生成器原理讲到过<code>yield</code>会让函数出栈，也就是让出执行权，实际上<code>await</code>没有此功能，他在一定程度上等同于<code>yield from</code>，负责将这些协程链接起来，没有将函数出栈的能力。</p>
<p>两个示例代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, coro</span>):</span><br><span class="line">        <span class="variable language_">self</span>.coro = coro</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                x = <span class="variable language_">self</span>.coro.send(<span class="literal">None</span>) <span class="comment"># 程序从此处开始 执行</span></span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">                result = e.value</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">isinstance</span>(x, YieldFrom)</span><br><span class="line">                func, arg = x.value</span><br><span class="line">                func(arg)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">one_task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'begin big_step'</span>)</span><br><span class="line">    big_result = <span class="keyword">await</span> big_step()</span><br><span class="line">    <span class="built_in">print</span>(big_result)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">big_step</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'begin small step'</span>)</span><br><span class="line">    small_result = <span class="keyword">await</span> small_step()</span><br><span class="line">    <span class="built_in">print</span>(small_result)</span><br><span class="line">    <span class="keyword">return</span> small_result * <span class="number">1000</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">small_step</span>():</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    <span class="keyword">await</span> Awaitable((sleep, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">assert</span> time.time - t1 &gt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Awaitable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = obj</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__await__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="variable language_">self</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.value</span><br></pre></td></tr></table></figure>
<p><code>await</code>会将<code>send</code>一层一层地传递下去，这里不会造成阻塞，直到运行到了<code>Awaitable</code>中的<code>yield</code>，此时开始出栈，并向上传播，造成<code>corotine</code>在<code>await</code>这个地方暂停，由此<code>send</code>函数也就返回了，<code>Task.run</code>继续向下运行。</p>
<p>协程都让出了执行权，但这个<code>Task.run</code>还在这里运行，那么前面的协程不久白出栈了吗，所以<code>Task.run</code>函数必须要退出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, coro</span>):</span><br><span class="line">        <span class="variable language_">self</span>.coro = coro</span><br><span class="line">        <span class="variable language_">self</span>._done = <span class="literal">False</span></span><br><span class="line">        <span class="variable language_">self</span>._result = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>._done:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 只有任务还没有结束时 才 send</span></span><br><span class="line">                x = <span class="variable language_">self</span>.coro.send(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="variable language_">self</span>._result = e.value</span><br><span class="line">                <span class="variable language_">self</span>._done = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">isinstance</span>(x, Awaitable)</span><br><span class="line">                <span class="comment">#func, arg = x.value</span></span><br><span class="line">                <span class="comment">#func(arg) 程序运行一半就结束了 但还是阻塞了2秒 所以这个操作不应该在这里执行</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'task done'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = Task(one_task())</span><br><span class="line">    t.run()</span><br><span class="line">    <span class="comment"># 等待2s 的时间做其他的事</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'doing other thing..'</span>)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">    t.run()</span><br><span class="line">    <span class="comment"># 以上是完成了手动调度任务 实际上我们需要一个东西来自动调度的 也就是 event loop</span></span><br></pre></td></tr></table></figure>
<p>返回值通过作为<code>await</code>表达式语句的返回值一层一层往上游传递，最顶层的<code>corotine</code>则通过 <code>except  StopIteration</code>传递出来，也就意味着这个任务真正地结束了。</p>
<p>实验代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Awaitable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="variable language_">self</span>.value = obj</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__await__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="variable language_">self</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, coro</span>):</span><br><span class="line">        <span class="variable language_">self</span>.coro = coro</span><br><span class="line">        <span class="variable language_">self</span>._done = <span class="literal">False</span></span><br><span class="line">        <span class="variable language_">self</span>._result = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>._done:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 只有任务还没有结束时 才 send</span></span><br><span class="line">                x = <span class="variable language_">self</span>.coro.send(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">                <span class="variable language_">self</span>._result = e.value</span><br><span class="line">                <span class="variable language_">self</span>._done = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">assert</span> <span class="built_in">isinstance</span>(x, Awaitable)</span><br><span class="line">                <span class="comment">#func, arg = x.value</span></span><br><span class="line">                <span class="comment">#func(arg) 程序运行一半就结束了 但还是阻塞了2秒 所以这个操作不应该在这里执行</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'task done'</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">small_step</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"working.."</span>)</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    <span class="keyword">await</span> Awaitable((sleep, <span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"working ..."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">big_step</span>():</span><br><span class="line">    small_result = <span class="keyword">await</span> small_step()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"small step end with <span class="subst">{small_result}</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> small_result * <span class="number">1888</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">one_task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"start task"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"begin big step"</span>)</span><br><span class="line">    big_result = <span class="keyword">await</span> big_step()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'endbigstep'</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'end task'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t = Task(one_task())</span><br><span class="line">    t.run()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"do other things"</span>)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">    t.run()</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.pengunix.icu">Pengunix</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.pengunix.icu/2024/10/04/4ba1673ea04b/">https://blog.pengunix.icu/2024/10/04/4ba1673ea04b/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.pengunix.icu" target="_blank">Pengunix</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://bing.img.run/rand_1366x768.php" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/04/f95b71a1d9d1/" title="Django-补"><img class="cover" src="https://bing.img.run/rand_1366x768.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Django-补</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/30/7fcca776c9f6/" title="STM32究极复杂的定时器"><img class="cover" src="https://bing.img.run/rand_1366x768.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">STM32究极复杂的定时器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/10/04/f95b71a1d9d1/" title="Django-补"><img class="cover" src="https://bing.img.run/rand_1366x768.php" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-04</div><div class="title">Django-补</div></div></a></div><div><a href="/2023/10/29/de8c747b1e77/" title="OPENCV-图像处理-1"><img class="cover" src="https://bing.img.run/rand_1366x768.php" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">OPENCV-图像处理-1</div></div></a></div><div><a href="/2023/07/15/2cc649159e1d/" title="协程入门"><img class="cover" src="https://bing.img.run/rand_1366x768.php" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-15</div><div class="title">协程入门</div></div></a></div><div><a href="/2024/08/04/a6f8bbde2474/" title="正则表达式"><img class="cover" src="https://bing.img.run/rand_1366x768.php" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-04</div><div class="title">正则表达式</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Pengunix</div><div class="author-info__description">一般技术，一般博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/pengunix"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/pengunix" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/357944209" target="_blank" title="Bilibili"><i class="fab fa-bilibili" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">STM32,完辣!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82"><span class="toc-number">1.</span> <span class="toc-text">python一些细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 浮点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-class%E9%87%8C%E7%9A%84%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E6%96%B9%E6%B3%95%E7%9A%84-self%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 class里的函数如何变成方法的(self作用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 鸭子类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-assert-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 assert 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E6%89%BE%E5%88%B0%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%85%B1%E5%90%8C%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 找到可迭代对象共同的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.1.</span> <span class="toc-text">常见的可迭代对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">了解如何定义一个迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.6.3.</span> <span class="toc-text">迭代器协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">迭代器的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.6.5.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-yield%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.yield关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.术语解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3yield%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.深入理解yield关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5or%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">语句or表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#yield-%E5%AF%B9%E5%87%BD%E6%95%B0%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">yield 对函数做了什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8-yield"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">在循环中使用 yield</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%8A%B6%E6%80%81"><span class="toc-number">1.7.3.4.</span> <span class="toc-text">生成的四个状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8yield%E9%87%8D%E6%9E%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.7.3.5.</span> <span class="toc-text">使用yield重构迭代器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E8%A6%81-%E7%94%9F%E6%88%90%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.3.6.</span> <span class="toc-text">(重要) 生成器技术实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%EF%BC%88yield%EF%BC%89"><span class="toc-number">1.7.3.7.</span> <span class="toc-text">协程（yield）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#yield%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95"><span class="toc-number">1.7.3.8.</span> <span class="toc-text">yield三种用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%EF%BC%88yield-from"><span class="toc-number">1.7.3.9.</span> <span class="toc-text">协程（yield from)</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/04/f95b71a1d9d1/" title="Django-补">Django-补</a><time datetime="2024-10-04T06:22:58.000Z" title="发表于 2024-10-04 14:22:58">2024-10-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/04/4ba1673ea04b/" title="不基础的python基础-补">不基础的python基础-补</a><time datetime="2024-10-04T06:07:58.000Z" title="发表于 2024-10-04 14:07:58">2024-10-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/30/7fcca776c9f6/" title="STM32究极复杂的定时器">STM32究极复杂的定时器</a><time datetime="2024-09-30T12:00:54.000Z" title="发表于 2024-09-30 20:00:54">2024-09-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/15/54ecb1b07c2b/" title="STM32裸机与FreeRTOS下串口协议选型与对比">STM32裸机与FreeRTOS下串口协议选型与对比</a><time datetime="2024-09-15T12:04:52.000Z" title="发表于 2024-09-15 20:04:52">2024-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/07/4370a414ea46/" title="在Archlinux下配置stm32开发环境">在Archlinux下配置stm32开发环境</a><time datetime="2024-09-07T08:43:31.000Z" title="发表于 2024-09-07 16:43:31">2024-09-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By Pengunix</div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20240143" target="_blank">萌ICP备20240143号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.8.0/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div></div></body></html>