{"posts":[{"title":"OPENCV-图像处理-1","text":"图片基本操作12345678910111213import cv2import matplotlib.pyplot as pltimport numpy as np%matplotlib inline # 直接展示图片 无需 .showimg = cv2.imread(&quot;a.png&quot;) # 默认BGR模式# def show(img):# 显示图片cv2.imshow(&quot;窗口标题&quot;, img)# 等待时间 0 为一直等 按任意键关闭cv2.waitKey(0)cv2.destroyAllWindows() imread以某种模式加载图片 12img = cv2.imread(&quot;/path/to/img&quot;, cv2.IMREAD_***) # IMREAD_GRAYSCALE等模式img.shape # 只有两个维度 imwrite写入图片 1cv2.imwrite(&quot;/path/to/img&quot;, img) 视频读取 cv2.VideoCapture可以捕获摄像头，用数字来控制不同设备 如果是视频文件，直接指定路径 播放灰度视频123456789101112131415161718vc = cv2.VideoCapture(&quot;/path/to/video&quot;)# vc = cv2.VideoCapture(0) 打开视频设备if vc.isOpened(): open, frame = vc.read()else: open = Falsewhile open: ret, frame = vc.read() if frame is None: break if ret = True: gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # 转为灰度图 cv2.imshow('result', gray) if cv2.waitKey(10) &amp; 0xFF == 27: breakvc.release()cv2.destroyAllWindows() 截取部分图像数据123img = cv2.imread(&quot;cat.jpg&quot;)cat = img[0:200, 0:200]cv_show(&quot;cat&quot;, cat) 颜色通道提取合并1234567b,g,r = cv2.split(img)img = cv2.merge(b, g, r)# 只保留Rcur_img = img.copy()cur_img[:, :, 0] = 0cur_img[:, :, 1] = 0 边界填充1234567891011top_size, bottom_size, left_size, right_size = (50, 50, 50, 50)# 复制边缘像素relicate = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REPLICATE)# 边界镜面反射reflect = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REFLECT)reflect101 = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REFLECT_101)# 用另一侧的像素来填充wrap = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_WRAP)# 常数填充，指定value参数，0为黑色constant = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_CONSTANT, value=0) 数值计算数组加法，每个数值都加，uint8溢出自动取模 12img += 256img[:5, :, 1] 两个array shape 相同时，同样可以相加 12345# 溢出自动取模img1 += img2img1[:5, :. 1]# 不溢出，加到最大值255cv2.add(img1, img2)[:5, :, 0] 图像融合 概念：广播操作 通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状； 对生成的数组执行按元素操作。 如果直接相加123img1 + img2 # shape相同正常# shape 不同ValueError: operands could not be broadcast（广播机制） with shape (h, w, c) (h, w, c) resize 后相加12345678img1 = cv2.resize(img_dog, (h, w))co = cv2.resize(img, (0, 0), fx=3, fy=1) # w伸长三倍# plt.imshow(co, 'gray')# 权重相加# res = a*img1 + b*img2 + bias# a, b权重res = cv2.addWeighted(img1, 0.4, img2, 0.6, 0) 图像阈值ret, dst = cv2.threshold(src, thresh, maxval, type) src: 输入图，只能输入单通道图像，通常灰度图 dst: 输出图 thresh: 阈值 maxval: 当像素值超过了阈值（或小于阈值，由type决定）,所赋予的值 type: 二值化操作的类型，包含以下五种类型： THRESH_BINARY 超过阈值部分取最大值，否则取零 THRESH_BINARY_INV THRESH_BINARY反转 THRESH_TRUNC 截断，大于阈值部分设为阈值，否则不变 THRESH_TOZERO 大于阈值部分不变，否则设为0 THRESH_TOZERO_INV 反转 图像平滑处理均值滤波平均卷积操作 1blur = cv2.blur(img, (3, 3)) 方框滤波和均值滤波一样，但可以选择归一化 123box = cv2.boxFilter(img, -1, (3, 3), normalize=True) # 与均值滤波相同box = cv2.boxFilter(img, -1, (3, 3), normalize=False)# 只相加，不作均值操作，溢出保留最大值 高斯滤波123# 高斯滤波# 高斯模糊的卷积核里的数值满足高斯分布，中间的权重比较大aussian = cv2.GaussianBlur(img, (9,9), 1) 中值滤波12median = cv2.medianBlur(img, 5)# 一般中值滤波可快速解决噪点问题 多张图片同时显示1234res = np.hstack((img1, img2, ...))show(res)res = np.vstack((img1, img2, ...))show(res)","link":"2023/10/29/OPENCV-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-1/"},{"title":"协程入门","text":"python 异步1.1 事件循环理解为一个死循环，检测并执行某些代码。 12345import asyncio# 生成或获取一个事件循环loop = asyncio.get_event_loop()# 将任务放入任务列表loop.run_until_complete(任务) 1.2 快速上手协程函数，定义函数使用 async def 关键字 12async def func(): ... 协程对象，执行协程函数得到的协程对象 1result = func() # 得到协程对象，不会执行函数 如果想要运行协程函数内部代码，必须要将协程对象交给事件循环 123456# 生成或获取一个事件循环loop = asyncio.get_event_loop()# 将任务放入任务列表loop.run_until_complete(result)# 或者asyncio.run(result) # python3.7+ 1.3 await 关键字await 可等待的对象(协程对象，Future 对象，task 对象 -&gt; io 等待) 12345678import asyncioasync def func(): ... response = await asyncio.sleep(2) print(response)result = func()asyncio.run(result) 123456789101112import asyncioasync def others(): print(&quot;start&quot;) await asyncio.sleep(2) print(&quot;end&quot;) return 'return'async def func(): print(&quot;code inside coroutine func&quot;) response = awat others() print(&quot;io req over&quot;)asyncio.run(func()) 等待对象的值得到结果之后再往下进行 1.4 task 对象在事件循环中添加多个任务。 用于并发调度协程，通过asyncio.create_task(协程对象)‘的方式创建 task 对象，这样可以让协程加入事件循环中等待被调度执行。除了使用create_task函数之外，还可用低层级的loop.create_task()或ensure_future()函数，不建议手动实例化 task 对象。 123456789101112131415161718192021import asyncioasync def func(): print(1) await asyncio.sleep(1) print(2) return &quot;return&quot;async def main(): print(&quot;main开始&quot;) # 创建task对象，将当前执行的func函数任务添加到事件循环。 task1 = asyncio.create_task(func()) task2 = asyncio.create_task(func()) print(&quot;main结束&quot;) # 当执行某协程遇到io操作时，会自动化切换成其他任务。 # 此处的await时等待相对应的协程全部执行完毕并获取结果 ret1 = await task1 ret2 = await task2 print(task1, task2)asyncio.run(main()) 1234567891011121314151617181920async def main(): print(&quot;main开始&quot;) task_list = [ asyncio.create_task(func()), asyncio.create_task(func()) ] print(&quot;main结束&quot;) # done 为返回值的集合 # timeout 最多等2秒 done, pending = await asyncio.wait(task_list, timeout=2) print(done)asyncio.run(main())# OUTPUT:'''1122{&lt;Task finished name='Task-3' coro=&lt;func() done, defined at /home/naii/pypy/coroutine.py:4&gt; result='return'&gt;, &lt;Task finished name='Task-2' coro=&lt;func() done, defined at /home/naii/pypy/coroutine.py:4&gt; result='return'&gt;}''' 12# 可在创建任务时指定name属性asyncio.create_task(func(), name='n1') task 对象可将协程对象立即放入事件循环中 1.5 asyncio future 对象是 task 类的基类，task 对象内部 await 结果的处理基于 future 对象来的 1234567891011import asyncioasync def func(): # 获取当前事件循环 loop = asyncio.get_running_loop() # 创建一个任务（future对象），这个任务什么都不做 fut = loop.create_future() # 等待任务最终结果（future对象），没有结束一直等下去。 await futasyncio.run(func())# 此程序会一直阻塞下去 12345678910111213141516171819import asyncioasync def set_after(fut): await asyncio.sleep(2) fut.set_result('666')async def main(): # 获取当前事件循环 loop = asyncio.get_event_loop() # 创建一个任务（future对象），没有绑定任何行为，则这个任务不会结束 fut = loop.create_future() # 创建一个任务（task对象）绑定了set_after函数，函数内部在2s后给fut赋值 # 相当于手动给fut赋值，那么fut就会结束了 await loop.create_task(set_after(fut)) # 等待future对象获取最终结果 data = await fut print(data)asyncio.run(main()) 1.6 concurrent.futures.future 对象使用线程池、进程池来实现异步操作时用到的对象。 123456789101112131415import timefrom concurrent.futures import Futurefrom concurrent.futures.thread import ThreadPoolExecutorfrom concurrent.futures.process import ProcessPoolExecutordef func(value): time.sleep(1) print(value)# 创建线程池pool = ThreadPoolExecutor(max_workers=5)# 或者 pool = ProcessPoolExecutor(max_workers=5) 创建进程池for i in range(10): fut = pool.submit(func, i) print(fut) 例如：crm 项目内部数据都是基于协程的+mysql（不支持）此时使用两者交叉使用 123456789101112131415161718192021222324252627import timeimport asyncioimport concurrent.futuresdef func(): # 某个耗时操作 time.sleep(2) return &quot;aa&quot;async def main(): loop = asyncio.get_running_loop() # 1. Run in default loop's executor（默认ThreadPoolExecutor） # 第一步：内部会先调用 ThreadPoolExecutor的submit方法去线程池中申请一个线程去执行func函数 # 并返回一个concurrent.futures.Future对象 # 第二步：调用asyncio.wrap_future将concurrent.futures.Future对象包装为asyncio.Future对象 # 因为concurrent.futures.Future对象不支持await语法，所以需要包装为asyncio.Future对象才能使用 fut = loop.run_in_executor(None, func) result = await fut print('default thread pool', result) # 2. Run in a custom thread pool # with concurrent.futures.ThreadPoolExecutor() as pool: # result = await loop.run_in_executor(pool.func1) # print(result)asyncio.run(main()) 案例：asyncio + 不支持异步的模块 12345678910111213141516171819202122232425import asynciofrom pip import mainimport requestsasync def download(url): # 发送网络请求，下载图片（遇到网络下载图片的io请求，自动切换到其他任务） print(&quot;开始下载&quot;, url) loop = asyncio.get_event_loop() # requests 模块默认不支持异步操作，所以就使用线程池来配合实现了。 future = loop.run_in_executor(None, requests.get, url) response = await future print(&quot;下载完成&quot;) # 图片保存到本地 file_name = url.rsplit('_')[-1] with open(file_name, mode='wb') as f: f.write(response.content)if __name__ == '__main__': url_list = [...] tasks = [download(url) for url in url_list] loop = asyncio.get_event_loop() 1.7 异步迭代器什么是异步迭代器 实现了__aiter__()和__anext__()方法的对象，__anext__必须返回一个 awaitable 对象，async_for 会处理异步迭代器的__anext__()方法所返回的可等待对象，直至其引发一个 StopAsyncIteratin 异常 什么是异步可迭代对象 可在 async_for 语句中被使用的对象，必须通过他的__aiter__()方法返回一个 asyncchronous_iterator 123456789101112131415161718192021222324252627282930import asyncioclass Reader(object): # 自定义异步迭代器（同时也是异步可迭代对象） def __init__(self) -&gt; None: self.count = 0 async def readline(self): # await asyncio.sleep(1) self.count += 1 if self.count == 100: return None return self.count def __aiter__(self): return self async def __anext__(self): val = await self.readline() if val == None: raise StopAsyncIteration return valasync def func(): obj = Reader() async for item in obj: print(item)asyncio.run(func()) 1.8 异步上下文管理这种对象通过定义__aenter__()和__aexit__()方法来对async_with语句中的环境进行控制。 123456789101112131415161718192021222324import asyncioclass AsyncContextManager: def __init__(self) -&gt; None: self.conn = conn async def do_something(self): # 例如：异步操作数据库 return 666 async def __aenter__(self): # 异步链接数据库 self.conn = await asyncio.sleep(1) return self async def __aexit__(self, exc_type, exc, tb): # 异步关闭数据库 await asyncio.sleep(1)async def func(): obj = AsyncContextManager() async with obj as f: result = await f.do_something() print(result)asyncio.run(func()) 1.9 uvloop是 asyncio 事件循环的替代方案。uvloop 事件循环的效率&gt;默认 asyncio 的事件循环。 安装 1pip install uvloop 1234567import asyncioimport uvloopasyncio.set_event_loop_policy(uvloop.EventLoopPolicy())# 编写asyncio的代码，没有变化# 内部的事件循环会自动变为uvloopasyncio.run(...) 注意：一个 asgi -&gt; uvicorn django3 fastapi 内部使用 uvloop 实战2.1 异步操作 redis两台主机之间，操作 redis 时存在链接/操作/断开都是网络 io 1pip install aioredis 1234567891011121314151617181920212223import asyncioimport aioredisasync def executeimport asyncioimport aioredisasync def execute(address, password): print('开始执行', address) # 网络io操作：创建redis链接 redis = await aioredis.create_redis(address, password=password) # 网络io操作：在redis中设置哈希值car，内部再设置三个键值对，即： # redis = {car: {key1:1, key2:2, key3:3}} await redis.hmset_dict('car', key1=1, key2=2, key3=3) # 网络io操作：去redis中获取值 result = await redis.hgetall(&quot;car&quot;, encoding='utf-8') print(resut) redis.close() # 网络io操作：关闭redis链接 await redis.wait_closed()asyncio.run( execute('...', '...') ) 12345task_list = [ execute(..., ...), # 不能在此处创建task对象，还未创建事件循环 execute(..., ...)]asyncio.run(asyncio.wait(task_list)) 2.2 异步操作 mysql1pip install aiomysql 12345678910111213141516171819202122import asyncioimport aiomysqlasync def execute(): # 网络io操作：链接mysql conn = await aiomysql.connect(host=&quot;127.0.0.1&quot;, port=3306, user=&quot;root&quot;, password=&quot;123&quot;, db='mysql') # 网络io操作：创建cursor cur = await conn.cursor() # 网络io操作：执行sql await cur.execute(&quot;select Host.User from user&quot;) # 网络io操作：获取sql结果 result = cur.fetchall() print(result) # 网络io操作：关闭链接 await cur.close() conn.close()asyncio.run(execute()) 链接多个 mysql 12345task_list = [ execute(..., ...), execute(..., ...)]asyncio.run(asyncio.wait(task_list)) 2.3 fastapi 框架异步安装 12pip install fastapipip install uvicorn # asgi 示例： 123456789101112# 同步写法import uvicornfrom fastapi import FastAPIapp = FastAPI()@app.get(&quot;/&quot;)def index(): # 普通操作接口 return {&quot;message&quot;: &quot;hello&quot;}# 脚本名称:appuvicorn.run(&quot;luffy:app&quot;, host=&quot;127.0.0.1&quot;, port=5000, log_level=&quot;info&quot;) 12345678# 异步写法@app.get(&quot;/read&quot;)async def read(): # 异步操作接口 print(&quot;收到请求&quot;) # 某个操作 await asyncio.sleep(3) return 666 redis 链接池 1234567891011121314REDIS_POOL = aioredis.ConnectionsPoll(&quot;redis://../&quot;, password=&quot;&quot;, minsize=1, maxsize=10)@app.get('/redis')async def redis_read(): # 连接池获取一个连接 conn = await REDIS_POOL.acquire() redis = Redis(conn) # 设置值 await redis.hmset_dict('car', key1=1, key2=2) # 读取值 result = await redis.hgetall('car', encoding='utf-8') print(redult) # 连接归还连接池 REDIS_POOL.release(conn) return result 2.4 异步爬虫1pip install aiohttp 12345678910111213141516171819import aiohttpimport asyncioasync def fetch(session, url): print(&quot;发送请求&quot;, url) async with session.get(url, verfy_ssl=False) as response: text = await response.text() print(&quot;得到结果&quot;, url, len(text))async def main(): async with aiohttp.ClientSession() as session: url_list = [ ..., ... ] tasks = [asyncio.create_task(fetch(session, url)) for url in url_list] done, pending = await asyncio.wait(tasks)asyncio.run(main())","link":"2023/07/15/%E5%8D%8F%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"title":"正则表达式","text":"正则表达式1.基础字符组: 由“[]”包裹 12345678[Pp]ythonPython python P[python]# 区间[a-zA-Z][0-9]# 特殊字符[\\-] ：\\ 加上特殊字符# 非集[^a-z] ：匹配非小写字母的其他任何元素 快捷方式 12345\\s:空白， 换行\\b word\\b:单词边界\\d:数字\\w：字母 \\W:匹配特殊字符非集：\\S \\B对应字母大写即可 字符的开始与结束 123456^:单词开始实例：python 123456 python^python : *python* 123456 python$:以n结尾python$ : python 123456 *python* 任意字符 1. :匹配任意字符,不能匹配换行符 可选字符 123? :字符出现零次或一次 非贪婪模式honur honrhonu?r : *honur* *honr* 范围、重复区间 1234\\d{9}\\d{1,9} : 贪婪模式 有9个匹配9个\\d{8,9}? : 匹配8个数字不匹配9个，非贪婪模式\\d{3,} :匹配三个以上数字 速写 1234567891011121314+ : 匹配1个到无数个 等价于 {1,}* : ·匹配0个到无数个 等价于 {0,}aa1a123123456a\\d+ :a*a1**a123*123456 2.分组、回溯、断言（环视）分组： 使用”()”1234567891011120731-8825951(\\d{4})-(\\d{7})Group 1: 0731Group 2: 88259512019-5013-082019 5013 082019501308(\\d{4})[\\-\\s]?(\\d{4})[\\-\\s]?(\\d{2})2019 5013 08 或者条件123使用管道符号 |(.jpg|.gif|.jpeg|.png)匹配对应图片后缀 非捕获分组：当我们不需要获取某个分组的内容，但是又想使用分组的特性，此时就可以使用非捕获组(?:表达式)，从而不不捕获数据，还能使用分组的功能 分组的回溯引用 12&lt;(\\w+)&gt;(.*?)&lt;/\\1&gt;匹配html标签内容 (\\w+)第一个分组 \\1代表回溯第一个分组 正向先行断言12喜欢(?=你)匹配喜欢右边有你的字符，不会匹配‘你’ 密码强度验证 必须包含 大小写字母 至少一个数字 至少 8 个字符 反向先行断言反向先行断言（?!表达式）作用是保证右边不能出现某个字符 12喜欢(?!你)匹配右边不是你的喜欢二字包含右边什么都没有的情况 正向后行断言(?&lt;=表达式)，指在某个位置向左看，表示所在位置左侧必须能匹配 例如：如果要取出喜欢两个字，要求喜欢的前面有我，后面有你，此时 1(?&lt;=我)喜欢(?=你) 反向后行断言(?&lt;!表达式) 例如：取出喜欢两个字，要求喜欢的前面没有我，后面没有你 1(?&lt;!我)喜欢(?!n)","link":"2024/08/04/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"算法基础图论","text":"并查集可以合并，可以查询联通关系的集合。初始化 1pre[i] = i; 找根 1234int root(int x) { if (pre[x] == x) return x; return root(pre[x]);} 合并 123void merge(int u, int v) { pre[root(u)] = root(v);} 查询u,v是否联通 123void query(int u, int v) { root(u) == root(v);} 路径压缩：经过$O(n)$找根操作后，直接将每个点的出点指向根。 123void root(u) { pre[u] = pre[u]==u ? u : root(pre[u]);} 换根操作：多出一个节点或一个连通块，可以将这个节点或连通块的根指向原来的连通块根，也可将原来的根指向新增的节点或连通块，前者称为按秩合并(小-&gt;大)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;vector&gt;using namespace std;using ll = long long;const int N = 2e5 + 10;int pre[N], cnt[N];int root(int x) { return pre[x] = (pre[x] == x ? x : root(pre[x])); }void merge(int x, int y) { pre[root(x)] = root(y); }bool isCon(int x, int y) { return root(x) == root(y); }int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) { pre[i] = i; } for (int i = 1; i &lt;= m; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; merge(u, v); } // 遍历每个点，每个点的根计数+1 for (int i = 1; i &lt;= n; ++i) { cnt[root(i)]++; } vector&lt;int&gt; v; // 存入非零点 for (int i = 1; i &lt;= n; ++i) { if (cnt[i]) v.push_back(cnt[i]); } sort(begin(v), end(v)); for (auto &amp;i : v) { cout &lt;&lt; i &lt;&lt; ' '; }} Dijkstra单源最短路单源：可以求任意一个点到某个点的最短路 123456graph LR1--&gt;|1|21--&gt;|4|32--&gt;|2|32--&gt;|2|43--&gt;|3|5 从1开始，数组d[i]存放1到i点距离的最小值。初始化d[1]=0,d[i] = inf1-&gt;2: d[2] = 11-&gt;3: d[3] = 42-&gt;3: d[3] = min(1+2, 4) = 32-&gt;4: d[4] = 1 + 2 = 33-&gt;5: d[5] = 3 + 3 = 6贪心思想：每次找最近的点进行拓展和更新dp：选取最优方案每个点只拓展更新一次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bitset&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;array&gt;using namespace std;using ll = long long;const int N = 1e3 + 5;// O(n^2)struct Edge { int x, w;};vector&lt;Edge&gt; g[N];array&lt;ll, N&gt; d;ll n, m;void dijkstra(int st) { d.fill(0x3f); d[st] = 0; bitset&lt;N&gt; vis; // 表示已经拓展过 for (int i=1;i&lt;=n;++i) { // 找出最小点，距离原点最近 int u = 1; for (int j = 1; j &lt;= n; ++j) { if (vis[u] || (!vis[j] &amp;&amp; d[j] &lt; d[u])) u = j; } vis[u] = 1; // 表示u已经拓展过 // d[u]已是最优的 for (auto &amp;[v, w] : g[u]) { if (!vis[v] &amp;&amp; d[v] &gt; d[u] + w) d[v] = d[u] + w; } }}int main() { cin &gt;&gt; n &gt;&gt; m; for (ll i=1;i&lt;=m;++i) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; if (u !=v) g[u].push_back({v, w}); } dijkstra(1); // 判断是否能到达 cout &lt;&lt; (d[n]&gt;= 0x3f3f3f3f3f3f3f3f ? -1 : d[n]) &lt;&lt; '\\n';} 最短路单调队列优化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bitset&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;array&gt;using namespace std;using ll = long long;const int N = 1e3 + 5;struct Edge { ll x, w; bool operator&lt;(const Edge &amp;v) const { // w小的优先 return w == v.w ? x &lt; v.x: w &gt; v.w; }};vector&lt;Edge&gt; g[N];array&lt;ll, N&gt; d;ll n, m;void dijkstra(int st) { d.fill(0x3f3f3f3f3f3f3f3f); d[st] = 0; bitset&lt;N&gt; vis; // 表示已经拓展过 priority_queue&lt;Edge&gt; pq; pq.push({st, d[st]}); while (pq.size()) { int x = pq.top().x;pq.pop(); // 防止反复入队 if (vis[x]) continue; vis[x] = 1; for (auto &amp;[y, w] : g[x]) { if (!vis[y] &amp;&amp; d[y] &gt; d[x] + w) { d[y] = d[x] + w; pq.push({y, d[y]}); } } }}int main() { cin &gt;&gt; n &gt;&gt; m; for (ll i=1;i&lt;=m;++i) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; if (u !=v) g[u].push_back({v, w}); } dijkstra(1); // 判断是否能到达 cout &lt;&lt; (d[n]&gt;= 0x3f3f3f3f3f3f3f3f ? -1 : d[n]) &lt;&lt; '\\n'; } Floyd多源最短路12345graph LR1--&gt;|1|22--&gt;|5|31--&gt;|2|44--&gt;|3|3 floyd由三重循环组成，第一层枚举中转点，第二层枚举入点，第三层枚举出点。有以下图，虚线代表路径中有其他节点。 1234graph LRi-.-&gt;ji-.-&gt;kk-.-j 那么从i到j的最短距离 1d[i][j]=min(d[i][j], d[i][k]+d[k][j]) 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;using ll = long long;const int N = 300;const ll inf = 4e18, p = 998244353;ll d[N][N], n, m, q;int main() { memset(d, 0x3f, sizeof d); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i=1;i&lt;=m;++i) { ll u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; d[u][v] = min(d[u][v], w); } // 排除自环 距离为0 for (int i=1;i&lt;=n;++i) { d[i][i]=0; } for (int k = 1; k &lt;= n; ++k) { for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { d[i][j] = min(d[i][j], d[i][k]+d[k][j]); } } } while (q--) { int u, v; cin &gt;&gt; u &gt;&gt; v; cout &lt;&lt; (d[u][v] &gt;= inf ? -1 : d[u][v]) &lt;&lt; '\\n'; }} 分层图最短路分层图图大小为k*n，一定要注意数据范围！！！以洛谷 P4568 [JLOI2011] 飞行路线为例。观察数据范围，$n \\times k, m \\times k \\leq 5 \\times 10^5$，所以将图分层是可行的。那么接下来就建k+1层图，每层图正常建边与原图相同，层与层之间用权值为0的边相连，建好后用最短路算法就可解决。 12345678910111213141516171819202122232425int main() { ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int s, t; cin &gt;&gt; s &gt;&gt; t; int a, b, c; for (int i = 0; i &lt; m; ++i) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; g[a].push_back({b, c}); g[b].push_back({a, c}); for (int j = 1; j &lt;= k; ++j) { g[a+(j-1) * n].push_back({b+j*n, 0}); g[b+(j-1)* n].push_back({a+j*n, 0}); g[a + j * n].push_back({b + j * n, c}); g[b+j*n].push_back({a+j*n, c}); } } for (int i = 1; i &lt;= k; ++i) { g[t+(i-1)*n].push_back({t+i*n, 0}); } dijkstra(s); cout &lt;&lt; d[t + k * n];} 分层图的核心理念： 将点拆开，复制多层图，并利用特殊构造的边将各层相连的建图方法。 一般用于边或点有特殊限制问题（如重复经过次数，多种价值选择等） 需要保证拆开后的总点数规模可接受。 补充分层图加网络最大流问题 最小生成树(MST)生成树：连通图中，找出一个节点最多的（n点），n-1条边的子连通图。最小是指在生成树中找到权值和最小的以下图为例： 1234567graph LR1---|2|21---|3|42---|3|32---|1|43---|4|54---|5|5 则最小生成树（虚线连接）为： 1234567graph LR1-.-|2|21---|3|42-.-|3|32-.-|1|43-.-|4|54---|5|5 基于点的Prim算法（稠密图）1234567graph LR1---|1|21---|3|42---|2|32---|1|43---|5|54---|3|5 两个集合intree和outtree 选1号点作为起点放入intree，移出outtree（以下步骤同理） 循环n-1次，每次确定一条边，在所有点当中找离intree中的点距离最近的点，将其加入intree，更新所有点到intree任意一点的最短距离。 在权值均为正的情况下，使用邻接表只需考虑intree集合中的点直接连接的点。如果使用邻接矩阵，非直接连接的点距离初始化为无穷大即可。 朴素 $O(n^2)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bitset&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;using ll = long long;const int N = 1e3 + 10;const ll inf = 4e18, p = 998244353;int a[N][N], d[N];bitset&lt;N&gt; intree;int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; memset(a, 0x3f, sizeof a); memset(d, 0x3f, sizeof d); for (int i = 1; i &lt;= n; ++i) { a[i][i] = 0; } for (int i = 1; i &lt;= m; ++i) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; // 排除无向图出现重边 a[u][v] = min(a[u][v], w); a[v][u] = min(a[v][u], w); } ll ans = 0; for (int i = 1; i &lt;= n; ++i) { int u = 1; // u就是距离intree点最近的点 for (int j = 1; j &lt;= n; ++j) { if (intree[u] || (!intree[j] &amp;&amp; d[j] &lt; d[u])) u = j; } if (d[u] &lt; 0x3f) ans += d[u]; intree[u] = 1; d[u] = 0; for (int j = 1; j &lt;= n; ++j) { if (intree[j]) continue; d[j] = min(d[j], a[u][j]); } } cout &lt;&lt; ans;} 堆优化 $O(n \\log n)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bitset&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;using ll = long long;const int N = 2e5 + 10;const ll inf = 4e18, p = 998244353;struct Edge { ll x, w; bool operator&lt;(const Edge &amp;u) const { return w ==u.w?x&lt;u.x:w&gt;u.w; }};vector&lt;Edge&gt; g[N];ll d[N];bitset&lt;N&gt; intree;int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; memset(d, 0x3f, sizeof d); for (int i = 1; i &lt;= m; ++i) { ll u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; g[u].push_back({v, w}); g[v].push_back({u, w}); } ll ans = 0; priority_queue&lt;Edge&gt; pq; pq.push({1, 0}); d[1] = 0; while (pq.size()) { // auto [x, w] = pq.top(); int x = pq.top().x; pq.pop(); if (intree[x]) continue; intree[x] = 1; // ans += w; ans += d[x]; d[x] = 0; for (auto &amp;[y, w] : g[x]) { if (!intree[y] &amp;&amp; w &lt; d[y]) { d[y] = w; pq.push({y, w}); } } } for (int i=1;i&lt;=n;++i) { if (!intree[i]) ans = -1; } cout &lt;&lt; ans &lt;&lt; '\\n';} 基于边的Kruskal算法（稀疏图）贪心、排序 $O(m \\log m) \\times O(并查集 \\approx 1)$ 给边从小到大排序 从小到大选边，若这条边的两个已经连通就跳过，若未连通就选上并连通。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;using ll = long long;const int N = 1e5 + 10;const ll inf = 4e18, p = 998244353;ll d[N];int pre[N];int root(int x) { return pre[x] = (pre[x] == x ? x : root(pre[x]));}struct Edge { ll u, v, w; bool operator&lt;(const Edge &amp;m) const { return w == m.w ? (u==m.w?v&lt;m.v:u&lt;m.w) : w &lt; m.w; // return w&lt;m.w; }};int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; memset(d, 0x3f, sizeof d); vector&lt;Edge&gt; es; for (int i=1;i&lt;=m;++i) { ll u, v, w;cin &gt;&gt; u&gt;&gt; v&gt;&gt; w; es.push_back({u, v, w}); } sort(es.begin(), es.end()); ll ans = 0; for (int i=1;i&lt;=n;++i) { pre[i] = i; } for (auto &amp;[u, v, w] : es) { if (root(u) == root(v)) continue; ans += w; pre[root(u)] = root(v); } for (int i=1;i&lt;n;++i) { if (root(i) != root(i+1)) ans = -1; } cout &lt;&lt; ans;}","link":"2024/01/30/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E5%9B%BE%E8%AE%BA/"},{"title":"算法基础数论","text":"因数和质因数分解质数判断复杂度：$O(\\sqrt{n})$ 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;using ll = long long;const int N = 2e5 + 10;const ll inf = 4e18, p = 998244353;bool isprime(int x) { if (x&lt;2) return false; for (int i = 2; i * i &lt; x; ++i) { if (x%i==0) return false; } return true;}int main() { int n; cin &gt;&gt; n; cout &lt;&lt; isprime(n);} 分解因数1234567891011121314151617int main() { ll n; cin &gt;&gt; n; vector&lt;ll&gt; v; for (ll i=1;i*i&lt;=n;++i) { if (n % i) continue; v.push_back(i); if (i != n/i) v.push_back(n/i); } sort(v.begin(), v.end()); for (auto &amp;i : v) { cout &lt;&lt; i &lt;&lt; ' '; }} 质因数分解123456789101112131415161718int main() { ll n; cin &gt;&gt; n; vector&lt;ll&gt; v; for (ll i=2;i*i&lt;=n;++i) { if (n % i) continue; v.push_back(i); // 除干净i logn while (n % i == 0) n/=i; } if (n&gt;1) v.push_back(n); sort(v.begin(), v.end()); for (auto &amp;i: v) { cout &lt;&lt; i &lt;&lt; ' '; }} 素数筛1、埃氏筛法复杂度: $O(n \\log \\log n)$使用bitset记录下标是否为素数，如：0代表下标是素数未被筛除，1代表不是素数被筛除。b[0]=1，b[1]=1，b[2]=0，b[3]=02和3均为素数，将其倍数标记为筛除，继续遍历以此类推 1234567891011121314151617181920212223#include &lt;bitset&gt;#include &lt;iostream&gt;using namespace std;using ll = long long;const int N = 2e6 + 10;bitset&lt;N&gt; vis;int main() { int n; cin &gt;&gt; n; vis[0] = vis[1] = 1; for (int i = 2; i &lt;= n; ++i) { if (!vis[i]) // 从其最近的倍数开始，步长为i，筛掉i的倍数 // int j = i*i更好，2i会被2筛掉，3i会被3筛掉... for (int j = 2 * i; j &lt;= n; j += i) vis[j] = 1; } for (int i = 1; i &lt;= n; ++i) if (!vis[i]) cout &lt;&lt; i &lt;&lt; ' ';} 2、欧拉筛一般埃氏筛能满足大多数要求，以后用到就补充。 GCD和LCM唯一分解定理自然数N可以唯一分解成几个数幂连乘的形式。$$N=P_1^{a_1} \\times P_2^{a_2} \\times \\cdots \\times P_m^{a_m}$$例如：$$\\begin{align}A=&amp;P_1^{a_1} \\times P_2^{a_2} \\times \\cdots \\times P_m^{a_m} \\\\B=&amp;P_1^{b_1} \\times P_2^{b_2} \\times \\cdots \\times P_n^{b_n} \\\\12 =&amp; 2^2 \\times 3^1 \\times 7^0\\\\21 =&amp; 2^0 \\times 3^1 \\times 7^1\\end{align}$$则 $$ gcd = 2^{min\\{2, 0\\}} \\times 3^{min\\{1, 1\\}} \\times 7^{min\\{0, 1\\}} = 2^0 \\times 3^1 \\times 7^0 = 3 $$ $$ lcm = 2^{max\\{2, 0\\}} \\times 3^{max\\{1, 1\\}} \\times 7^{max\\{0, 1\\}} = 2^2 \\times 3^1 \\times 7^1 = 84 $$ 辗转相除法已知$$a, b \\in N, a\\leq b, gcd(a, b) = gcd(a, b-a)$$则 $$ \\begin{align} gcd(a, b) =& gcd(a, b-a) \\\\ =& gcd(a, b-2a) \\\\ =& gcd(a, b-3a) \\\\ =&gcd(a, b \\% a) \\\\ & 若右小于左, 交换位置\\\\ =& gcd(b\\%a = c, a)\\\\ =& gcd(c, a-c)\\\\ =& gcd(c, a\\%c)\\\\ & 若右侧减到0说明 gcd(c, 0) = c \\end{align} $$ 结合唯一分解定理则$$a\\times b = gcd(a, b) \\times lcm(a, b)$$代码实现gcd, lcm 1234567ll gcd(ll a, ll b) { return b==0 ? a : gcd(b, a%b); }ll lcm(ll a, ll b) { // a*b/gcd(a,b)可能会溢出long long return a/gcd(a, b) * b;} 在numeric和万能头中也有实现,例如 12345678#include &lt;numeric&gt;// 或#include &lt;bits/stdc++.h&gt;...int main() { cout &lt;&lt; gcd(12, 21); cout &lt;&lt; lcm(12, 21);} 快速幂复杂度: $O(\\log n)$求$a^b % c$, 或其他在取模前会溢出的式子。已知以下等式： $$ \\begin{align} (a+b) \\% p =& (a\\%p + b\\%p)\\%p \\\\ (a-b) \\% p =& (a\\%p - b\\%p)\\%p \\\\ (a\\times b) \\% p =& (a\\%p \\times b\\%p)\\%p \\\\ \\end{align} $$ 那么$$\\begin{align}a^b=&amp;a \\times a \\times a \\cdots \\times a \\\\a^8=&amp;(a^4)^2 = ((a^2)^2)^2 \\\\a^{13} =&amp;(a^6)^2 \\times a\\end{align}$$ 所以：$$a^b = \\begin{cases}a^{b-1} \\times a, \\space &amp;if\\space b\\space is\\space odd \\\\a^{\\frac{n}{2}} \\times a^{\\frac{n}{2}}, \\space &amp;if \\space b \\space is \\space even \\space not \\space 0 \\\\1, \\space &amp;if \\space b=0\\end{cases}$$实现： 12345678910int qpow(int a, int b){ int ans = 1; while(b){ if(b&amp;1) //如果n的当前末位为1 ans *= a; //ans乘上当前的a a *= a; //a自乘 b &gt;&gt;= 1; //n往右移一位 } return ans;} 如果需要模p 12345678910ll qpow(ll a, ll b, ll c) { ll res = 1; while (b) { if (b &amp; 1) res = res * a % c; a = a * a % c; // 右移会向下取整，会改变奇偶性 b &gt;&gt;= 1; } return res;} 乘法逆元$(\\frac{1}{a})\\mod p = b$，那么a和b互为逆元。逆元可以用来计算以下算式： $$ (\\frac{a \\times b}{c}) \\% p = (a \\times b \\times \\frac{1}{c}) \\% p = (a \\times b \\times inv(c)) \\%p $$ $inv(c)$为c的逆元。 使用费马小定理求逆元：对于一个素数P，始终有 $$\\begin{align}(a^{P-1}) \\mod P =&amp; 1 \\mod P \\\\\\frac{1}{a} =&amp; a^{P-2} \\mod P\\end{align}$$例如： $$\\begin{align}\\frac{ax+b}{cx} \\mod P=&amp; (ax+b)\\times inv(cx) \\mod P\\\\=&amp;(ax+b) \\times (cx)^{P-2} \\mod P\\end{align}$$ 实现： 123ll inv(ll x) { return qpow(x, p-2);} 欧拉定理欧拉函数$$\\varphi(n) = \\prod_{i=1}^r p_i^{k_i-1} = \\prod_{p|n}p^{ \\alpha_p-1} = n \\prod_{p|n}(1- \\frac{1}{p})$$ 表示$[1, n]$中与n互质的数的个数。$\\varphi(1)=1$ 欧拉定理：$$a^{\\varphi(b)} \\equiv 1 \\mod b$$当b为素数就是费马小定理。","link":"2024/01/23/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/"},{"title":"第一节 线性方程组的解法","text":"解线性方程组的矩阵消元法例 1： $$ \\begin{cases} x_1+3x_2+x_3=2 \\\\ 3x_1+4x_2+2x_3=9 \\\\ -x_1-5x_2+4x_3=10 \\\\ 2x_1+7x_2+x_3=1 \\end{cases}$$ $$\\begin{pmatrix}1&amp;3&amp;1&amp;2\\\\3&amp;4&amp;2&amp;9\\\\-1&amp;-5&amp;4&amp;10\\\\2&amp;7&amp;1&amp;1\\\\\\end{pmatrix}$$ 我们所学过的加减消元法没有一定的规律。要使用计算机来解就要有一个规律。首先，以第一个方程为基础消去$x_1$ $$\\begin{cases}\\begin{align}x_1+3x_2+x_3=&amp;2 \\\\-5x_2-x_3=&amp;3 \\quad ➁+➀\\cdot(-3) \\\\-2x_2+5x_3=&amp;12 \\quad ➂+➀\\cdot1 \\\\x_2-x_3=&amp;-3 \\quad ➃+➀ \\cdot(-2)\\end{align}\\end{cases}$$ 消去$x_2$选择方程 ➁➂ 会出现分数，所以我们这次选择方程 ➃ 为基础。调换 ➁➃ $$(②,④) \\begin{cases}\\begin{align}x_1+3x_2+x_3=&amp;2 \\\\x_2-x_3=&amp;-3 \\\\-2x_2+5x_3=&amp;12 \\\\-5x_2-x_3=&amp;-3\\end{align}\\end{cases}$$ 以上消去$x_2 \\space x_3$的步骤省略，我们来看矩阵的解法。 $$\\begin{pmatrix}1&amp;3&amp;1&amp;2\\\\3&amp;4&amp;2&amp;9\\\\-1&amp;-5&amp;4&amp;10\\\\2&amp;7&amp;1&amp;1\\\\\\end{pmatrix}\\xrightarrow[]{➁+➀ \\cdot3,➂+➀ \\cdot1,➃+➀ \\cdot(-2)}\\begin{pmatrix}1&amp;3&amp;1&amp;2 \\\\0&amp;-5&amp;-1&amp;3 \\\\0&amp;-2&amp;5&amp;12 \\\\0&amp;1&amp;-1&amp;-3\\end{pmatrix}\\xrightarrow[]{(➁,➃)}\\begin{pmatrix}1&amp;3&amp;1&amp;2 \\\\0&amp;1&amp;-1&amp;-3 \\\\0&amp;-2&amp;5&amp;12 \\\\0&amp;-5&amp;-1&amp;3\\end{pmatrix}$$ $$\\xrightarrow[]{➂+➁ \\cdot2,➃+➁ \\cdot5}\\begin{pmatrix}1&amp;3&amp;1&amp;2 \\\\0&amp;1&amp;-1&amp;-3 \\\\0&amp;0&amp;3&amp;6 \\\\0&amp;0&amp;-6&amp;-12\\end{pmatrix}\\xrightarrow[]{➃+➂ \\cdot 2}\\begin{pmatrix}1&amp;3&amp;1&amp;2\\\\0&amp;1&amp;-1&amp;-3 \\\\0&amp;0&amp;3&amp;6 \\\\0&amp;0&amp;0&amp;0\\end{pmatrix}$$ 遇到全为零的一行（零行），我们来看一下此时的方程。 $$\\begin{cases}\\begin{align}x_1+3x_2+x_3=&amp;2 \\\\x_2-x_3=&amp;-3 \\\\3x_3=&amp;6\\end{align}\\end{cases}$$ 从下向上，可以依次解出三个 x 的值。这样的方程组叫做阶梯形方程组，矩阵叫做阶梯形矩阵。矩阵每行第一个不为零的元素称为主元。阶梯形矩阵： 零行在下方。 非零行主元的列指标随着行指标的增加而严格增大。我们继续 $$\\xrightarrow[]{➂ \\cdot \\frac{1}{3}}\\begin{pmatrix}1&amp;3&amp;1&amp;2 \\\\0&amp;1&amp;-1&amp;-3 \\\\0&amp;0&amp;1&amp;2 \\\\0&amp;0&amp;0&amp;0\\end{pmatrix}\\xrightarrow[]{➁+➂ \\cdot 1, ➀+➂ \\cdot (-1)}\\begin{pmatrix}1&amp;3&amp;0&amp;0 \\\\0&amp;1&amp;0&amp;-1 \\\\0&amp;0&amp;1&amp;2 \\\\0&amp;0&amp;0&amp;0\\end{pmatrix}\\xrightarrow[]{➀+➁ \\cdot (-3)}\\begin{pmatrix}1&amp;0&amp;0&amp;3 \\\\0&amp;1&amp;0&amp;-1 \\\\0&amp;0&amp;1&amp;2 \\\\0&amp;0&amp;0&amp;0\\end{pmatrix}$$ 此时, 方程的解如下。 $$\\begin{cases}x_1=3 \\\\x_2=-1 \\\\x_3=2\\end{cases}$$ 可以表示为 $$(3, -1, 2)$$ 同时，又出现了最终的阶梯形矩阵，其特点是 主元都是 1 主元所在列的其余元素都是 0叫做简化行阶梯形矩阵。得到这个矩阵我们的求解任务就完成了。在这个过程中用到了三种变换方式： 把一行的倍数加到另一行 两行互换 一行乘一个非零数这三种变换叫做矩阵的初等行变换，对应线性方程组的初等变换。初等变换不会影响方程组的解集，所以变换前后两个方程组是同解。例 2 ：$$\\begin{pmatrix}1&amp;-1&amp;1&amp;1 \\\\1&amp;-1&amp;-1&amp;3 \\\\2&amp;-2&amp;-1&amp;5\\end{pmatrix}\\xrightarrow[]{②+①\\cdot(-1),③+①\\cdot(-2)}\\begin{pmatrix}1&amp;-1&amp;1&amp;1 \\\\0&amp;0&amp;-2&amp;2 \\\\0&amp;0&amp;-3&amp;3\\end{pmatrix}\\xrightarrow[]{②\\cdot (-\\frac{1}{2}),③ \\cdot (-\\frac{1}{3})}\\begin{pmatrix}1&amp;-1&amp;1&amp;1 \\\\0&amp;0&amp;1&amp;-1 \\\\0&amp;0&amp;-1&amp;1\\end{pmatrix}\\xrightarrow[]{②+③}\\begin{pmatrix}1&amp;-1&amp;1&amp;1 \\\\0&amp;0&amp;1&amp;-1 \\\\0&amp;0&amp;0&amp;0\\end{pmatrix}\\xrightarrow[]{①+②}\\begin{pmatrix}1&amp;-1&amp;0&amp;2 \\\\0&amp;0&amp;-1&amp;1 \\\\0&amp;0&amp;0&amp;0\\end{pmatrix}$$简化方程组：$$\\begin{cases}\\begin{align}x_1-x_2=&amp;2 \\\\x_3=&amp;-1 \\\\0=&amp;0\\end{align}\\end{cases}\\rightarrow\\begin{cases}x_1=x_2+2 \\\\x_3=-1\\end{cases}$$这个表达式称为原方程组的一般解，其中以主元为系数的未知量$x_1, x_3$称为主变量，其余未知量$x_2$称为自由未知量。一般解就是含自由未知量的式子表示主变量。例 3：$$\\begin{pmatrix}1&amp;-1&amp;1&amp;1 \\\\1&amp;-1&amp;-1&amp;3 \\\\2&amp;-2&amp;-1&amp;3\\end{pmatrix}\\xrightarrow[]{②+①\\cdot(-1),③+①\\cdot(-2)}\\begin{pmatrix}1&amp;-1&amp;1&amp;1 \\\\0&amp;0&amp;-2&amp;2 \\\\0&amp;0&amp;-3&amp;1\\end{pmatrix}\\xrightarrow[]{②\\cdot (-\\frac{1}{2})}\\begin{pmatrix}1&amp;-1&amp;1&amp;1 \\\\0&amp;0&amp;1&amp;-1 \\\\0&amp;0&amp;-3&amp;1\\end{pmatrix}\\xrightarrow[]{③+②×3}\\begin{pmatrix}1&amp;-1&amp;1&amp;1 \\\\0&amp;0&amp;1&amp;-1 \\\\0&amp;0&amp;0&amp;-2\\end{pmatrix}$$最后相应的阶梯形方程组为$$\\begin{cases}\\cdots \\\\\\cdots \\\\0x_1+0x_2+0x_3=-2\\end{cases}$$显然最后一个方程无解，则整个方程组无解。综上：在有理数集（或实数集，或复数集）内，n 元线性方程组的解的情况有且只有三种可能 无解：其中一个方程组出现”$0=d (d \\neq 0)$”，否则原方程组有解。 有唯一解：非零行的数目等于未知量数。 有无穷多个解：非零行的数目小于未知量数。有解的两种情况我们作为定理 1，在下一篇文章给予证明。","link":"2023/06/18/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E8%A7%A3%E6%B3%95/"},{"title":"第二节 线性方程组解的情况及判别准则","text":"解的判别我们来证明上一篇的定理：n 元线性方程组经过初等行变换化成阶梯形。设阶梯形矩阵 J 有 r 个非零行，显然 J 有 n+1 列，最后一个非零行是第 r 行。情况 1：出现$0=d(d\\neq0)$则原方程组无解 （无需证明）情况 2：不出现$0=d(d\\neq0)$ J 的第 r 个主元$b_{rt}$不能位于第 n+1 列，因此行指标$t \\leq n$ 第一行的主元位于第一列，第二行位于第二列或向右几列，但随着行数增多第 r 行的主元的列指标 t 会$\\geq r$所以， $r\\leq t \\leq n$ 即非零行的数目不可能超过未知量的个数。我们继续分两种情况讨论。$$J （阶梯形矩阵）\\xrightarrow[]{初等行变换}J_1(简化行阶梯形矩阵)$$为了方便，我们把阶梯形矩阵进一步转化，其中 J1 也有 r 个非零行，从而 J1 有 r 个主元。情况 2.1：$r=n$此时 J1 有 n 个主元，形状如下$$J_1=\\begin{pmatrix}1&amp;0&amp;\\cdots&amp;0&amp;c_1 \\\\0&amp;1&amp;\\cdots&amp;0&amp;c_2 \\\\\\cdots &amp; \\cdots \\\\0&amp;0&amp;\\cdots&amp;1&amp;c_n \\\\0&amp;0&amp;0&amp;0&amp;0\\end{pmatrix}\\rightarrow只有唯一解:(c_1, c_2, \\cdots ,c_n)$$情况 2.2：$r &lt; n$$$J_1=\\begin{pmatrix}1 \\\\0&amp;\\cdots&amp;0&amp;1 \\\\0&amp;\\cdots&amp;\\cdots&amp;0&amp;\\cdots&amp;1\\end{pmatrix}$$其中包括第二个主元的列设为$j_2$，第三的主元的列设为$j_3$，依次类推。对应的主元第一个为$x_1$，第二个为$x_{j_2}$，第 r 为$x_{j_r}$。方程组（一般解）如下$$\\begin{cases}x_1=b_{11}x_{i_1}+b_{12}x_{i_2}+\\cdots + b_{1,n-r}x_{i_{n-r}} + d_1 \\\\x_{j_2}= b_{21}x_{i_1}+b_{22}x_{i_2}+\\cdots + b_{2,n-r}x_{i_{n-r}} + d_2 \\\\\\cdots \\\\x_{j_r}=b_{r1}x_{i_1}+b_{r2}x_{i_2}+\\cdots + b_{r,n-r}x_{i_{n-r}} + d_r\\end{cases}$$因为 r&lt;n,所以等号左侧的主变量个数也小于 n，右边肯定还有自由未知量$x_{i…}$可以取任意值，所以解是无数组。下面给出几个概念： 化成最终的阶梯形矩阵可能不同，但非零行数目一定相同，非零行的数目由矩阵的**秩(Rank)**决定。 如果一个线性方程组有解，那么称它是相容的，否则称它是不相容的。 上述解线性方程组的方法称为高斯-约当算法。 常数项全为零的线性方程组称为齐次线性方程组，(0,0,0,….)是齐次线性方程组的一个解，称为零解，其余的解(如果有)称为非零解。$$齐次线性方程组：\\begin{cases}a_{11}x_1+a_{12}x_2+\\cdots+a_{1n}x_n=0 \\\\a_{21}x_1+a_{22}x_2+\\cdots+a_{2n}x_n=0 \\\\\\cdots \\\\a_{s1}x_1+a_{s2}x_2+\\cdots+a_{sn}x_n=0 \\\\\\end{cases}$$推论 1：n 元齐次线性方程组的系数矩阵经过初等行变换化成的阶梯形矩阵的非零行个数 r&lt;n &lt;===&gt; 齐次线性方程组有非零解且它有无数组解。推论 2：n 元齐次线性方程组 如果方程的个数 s&lt;n，同时$r \\leq s$，则有非零解。 解、数域解是在有理数集（或实数集，或复数集）内的。不可能取整数集，因为限制过高连最基本 2x=1 都无解。给出以下定义定义 1：复数集的一个非空子集 K 如果满足 $0,1\\in K$ 至少两个元素。 $a,b \\in K ==&gt;a\\pm b, ab \\in K \\space 和 \\space a,b\\in K且b\\neq 0 ==&gt;\\frac{a}{b} \\in K$那么称 K 是一个数域。已有的数域包括有理数域 Q、实数域 R、复数域 C等等。整数集 Z不是，因为它对除法不封闭（运算结果不属于整数集）。 行列式关于以上讨论的 n 元线性方程组解的判别方法，自然会发现其不便之处，只有解到最后的阶梯形矩阵才判断出解的情况，因此需要探索一种新的解判别方法。以二元一次方程组为例，其中$a_{11},a_{21}$不全为零，不妨设$a_{11}\\neq 0$。 $$\\begin{cases}a_{11}x_1+a_{12}x_2=b_1 \\\\a_{21}x_1+a_{22}x_2= b_2\\end{cases}$$ $$\\begin{pmatrix}a_{11}&amp;a_{12}&amp;b_1 \\\\a_{21}&amp;a_{22}&amp;b_2\\end{pmatrix}\\xrightarrow[]{②+①×(-\\frac{a_{21}}{a_{11}})}\\begin{pmatrix}a_{11}&amp;a_{12}&amp;b_1 \\\\0&amp;a_{22}-\\frac{a_{21}}{a_{11}}a_{12}&amp;b_2-\\frac{a_{21}}{a_{11}}b_1\\end{pmatrix}\\longrightarrowM:\\begin{pmatrix}a_{11}&amp;a_{12}&amp;b_1 \\\\a_{21}&amp;\\frac{a_{11}a_{22}-a_{21}a_{12}}{a_{11}}&amp;b_2-\\frac{a_{21}}{a_{11}}b_1\\end{pmatrix}$$ 此时对元素 $m_{22}$ 讨论：情况 1：$a_{11}a_{22}-a_{21}a_{12} \\neq 0$，可继续带入求解，最终得到唯一解。情况 2：$a_{11}a_{22}-a_{21}a_{12} = 0$，若常数项不为零则无解，常数项为零则有无数解。所以以上表达式： $$\\left|\\begin{array}{cccc}a_{11} &amp; a_{12} \\\\a_{21} &amp; a_{22}\\end{array}\\right|:= a_{11}a_{22}-a_{21}a_{12}$$ 称为二阶行列式，也是原方程组系数矩阵的行列式。","link":"2023/07/05/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E8%A7%A3%E7%9A%84%E6%83%85%E5%86%B5%E5%8F%8A%E5%88%A4%E5%88%AB%E5%87%86%E5%88%99/"},{"title":"第三节 行列式","text":"数域 K 上已知一个二元一次方程组： $$\\begin{cases}a_{11}x_1+a_{12}x_2=b_1 \\\\a_{21}x_1+a_{22}x_2=b_2\\end{cases}$$ 其系数矩阵 $$A:\\begin{pmatrix}a_{11}&amp;a_{12} \\\\a_{21}&amp;a_{22}\\end{pmatrix}$$ 表示方法（二阶行列式）： $$det(A)=|A|=a_{11}a_{22}-a_{12}a_{21}$$ 在数域 K 上方程组有唯一解的充分必要条件是$|A|\\neq 0$。 从二阶行列式来看，计算结果就是一个对角线的积减去另一个对角线（反对角线）的积。定义：是 2!项代数和，其中每一项是取自不同行、不同列的两个元素的乘积，每一项的行指标成自然序（从小到大）排好位置。当列指标按自然序排列时，该项带正号。反之，该项带负号。 n 元排列1,2,…..,n 的一个全排列称为一个n 元排列。（或 n 个不同的正整数）1,2,….,n 形成的 n 元排列有 n!个。（或 n 个不同的正整数）例如三元排列有 123,132,213,231,312,321 共 6 个。四元排列 2431 从左到右 顺序（从小到大）的数对有：23,24逆序的数对有：21,43,41,31逆序的数对的数目称为这个排列的逆序数。所以 2431 的逆序数是 4，记作$\\tau (2431)=4$。逆序数是偶（奇）数的排列称为偶（奇）排列。 $$偶排列2431\\xrightarrow[]{4和1互换位置，其余的数不动称为一个对换,记作(4,1)}2134$$ 排列 2134 的逆序数为 1 是奇数，所以 2134 是一个奇排列。定理 1：对换改变排列的奇偶性。证明：先看对换的两个数相邻的情形： $$\\cdots i \\space j \\cdots (1) \\xrightarrow[]{(i,j)} \\cdots j \\space i \\cdots (2)$$ 排列对换后，i,j 二者顺序交换，顺序变为逆序，逆序变为顺序，其他数不变。排列（1）与（2）逆序数相差 1，从而排列（1）与排列（2）奇偶性相反。一般情形： $$\\cdots i \\space k_1 \\cdots k_s \\space j \\cdots (3)\\xrightarrow[]{(i,j)}\\cdots j \\space k_1 \\cdots k_s \\space i \\cdots (4)$$ 由两个数相邻的情形，可多次进行相邻对换来达到以上对换的效果。 $$\\cdots i \\space k_1 \\cdots k_s \\space j \\cdots (3)\\xrightarrow[]{(i,k_1) \\cdots (i,k_s),(i,j)}\\cdots k_1 \\cdots k_s \\space j \\space i \\cdots\\xrightarrow[]{(j,k_s)\\cdots (j,k_1)}\\cdots j \\space k_1 \\cdots k_s \\space i \\cdots (4)$$ 排列（2）到排列（4）经过(s+1)+s=2s+1 次相邻两数的对换。每变换一次改变一次奇偶性，经过奇数次，最终奇偶性相反。例如： $$25143 \\xrightarrow[]{(5,3)}23145 \\xrightarrow[]{(3,1)} 21345 \\xrightarrow[]{(2,1)} 12345(自然序，偶排列)$$ 定理 2：所以任意一个 n 元排列 $j_1,j_2, \\cdots j_n$到自然序排列$1, 2, 3, \\cdots n$可以经过一系列的对换互变且所作对换的次数与原排列的奇偶性相同。证明： $$j_1,j_2,j_3 \\cdots j_n \\xrightarrow[]{s次对换}1,2,\\cdots n (偶排列)$$ 设原排列是奇排列则 s 必为奇数，原排列是偶排列则 s 必为偶数。 n 阶行列式的定义定义 1：n 阶行列式是 n!项的代数和，其中每一项是不同行不同列的 n 个元素乘积，每一项按行指标成自然序排好位置，当列指标形成的排列是偶排列时，带正号，反之就带负号。 $$\\left|\\begin{matrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\a_{n1} &amp;a_{n2} &amp; \\cdots &amp;a_{nn}\\end{matrix}\\right|:=\\sum_{j_1j_2 \\cdots j_n} (-1)^{\\tau(j_1j_2 \\cdots j_n)}a_{1j_1}a_{2j_2}\\cdots a_{nj_n}\\space (1)$$ $$设A=\\begin{pmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\a_{n1} &amp;a_{n2} &amp; \\cdots &amp;a_{nn}\\end{pmatrix}$$ n 阶行列式（1）也称为 n 级矩阵 A 的行列式记作：|A|或 det A(1)式称为 n 阶行列式的完全展开式。矩阵 A 可以简记为$A=(a_{ij})$，其中$a_{ij}$称为 A 的(i,j)元。 一阶行列式$|a|=a$ 不要和实数的绝对值混淆，绝对值不能只等于其本身。 三阶行列式$$\\left|\\begin{matrix}a_{11}&amp;a_{12}&amp;a_{13} \\\\a_{21}&amp;a_{22}&amp;a_{23} \\\\a_{31}&amp;a_{32}&amp;a_{33} \\\\\\end{matrix}\\right|=a_{11}a_{22}a_{33}+a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32}-a_{13}a_{22}a_{31}-a_{11}a_{23}a{32}-a_{12}a_{21}a_{33}$$ 偶排列：123 312 231奇排列：132 321 213计算图解如下，可以记这个图 n 阶行列式$$\\left|\\begin{matrix}a_{11}&amp;a_{12}&amp;a_{13}&amp;\\cdots&amp;a_{1,n-2}&amp;a_{1,n-1}&amp;a_{1,n} \\\\0&amp;a_{22}&amp;a_{23}&amp;\\cdots&amp;a_{2,n-2}&amp;a_{2,n-1}&amp;a_{2,n} \\\\0&amp;0&amp;a_{33}&amp;\\cdots&amp;a_{3,n-2}&amp;a_{3,n-1}&amp;a_{3,n} \\\\\\vdots&amp;\\vdots&amp;\\vdots&amp;\\cdots&amp;\\vdots&amp;\\vdots&amp;\\vdots \\\\0&amp;0&amp;0&amp;\\cdots&amp;0&amp;a_{n-1,n-1}&amp;a_{n-1,n} \\\\0&amp;0&amp;0&amp;\\cdots&amp;0&amp;0&amp;a_{nn}\\end{matrix}\\right|=a_{11}a_{22}a_{33}\\cdots a_{n-1,n-1}a_{nn}$$ 主对角线下方元素全为零，这样的行列式称为上三角形行列式。命题 1：上三角形行列式的值等于主对角线上 n 个元素的乘积。 按行指标排列的 n 阶行列式的一项：$(-1)^{\\tau(j_1j_2 \\cdots j_n)}a_{1j_1}a_{2j_2}\\cdots a_{nj_n}$，但乘法具有交换律，所以可以总结出一个更通用的式子。例如：将三阶行列式中的$a_{12}a_{23}a_{31}$变为$a_{23}a_{12}a_{31}$，这时如何判断此项的符号呢？行指标 213 的逆序数是 1，列指标 321 的逆序数是 3，$(-1)^{1+3}=1$,所以符号为正。因此，这一项可以写成 $$(-1)^{\\tau(213)+\\tau(321)}a_{23}a_{12}a_{31}$$ 其他项同理: $$(-1)^{\\tau(i_1i_2\\cdot i_n)+\\tau(k_1k_2 \\cdots k_n)}a_{i_1k_1}a_{i_2k_2}\\cdots a_{i_nk_n}$$ 理由如下：首先 $$a_{1j_1}a_{2j_2}\\cdots a_{nj_n} \\xrightarrow[]{行s次对换+列s次对换}a_{i_1k_1}a_{i_2k_2}\\cdots a_{i_nk_n}$$ 根据定理 2 和定理 1： $$\\begin{align}(-1)^{\\tau(i_1i_2 \\cdots i_n)} =&amp; (-1)^s \\\\(-1)^{\\tau(j_1j_2 \\cdots j_n)}(-1)^s =&amp; (-1)^{\\tau(k_1k_2 \\cdots k_n)} \\\\\\end{align}$$ 从而 $$(-1)^{\\tau(i_1i_2 \\cdots i_n)+\\tau(k_1k_2 \\cdots k_n)}=(-1)^s \\cdot (-1)^{\\tau (j_1j_2 \\cdots j_n)}\\cdot (-1)^s=(-1)^{\\tau(j_1j_2 \\cdots j_n)}$$ 因此推论成立。根据以上分析，给定行指标的一个排列$i_1i_2 \\cdots i_n$，n 级矩阵 A 的行列式|A|为 $$|A|= \\sum_{k_1k_2 \\cdots k_n}(-1)^{\\tau(i_1i_2 \\cdots i_n)+\\tau(k_1k_2 \\cdots k_n)}a_{i_1k_1}a_{i_2k_2} \\cdots a_{i_nk_n}$$ 或给定列指标的一个排列$k_1k_1 \\cdots k_n$，n 阶行列式|A|为 $$|A|= \\sum_{i_1i_2 \\cdots i_n}(-1)^{\\tau(i_1i_2 \\cdots i_n)}a_{i_1k_1}a_{i_2k_2} \\cdots a_{i_nk_n}$$ 所以 n 阶行列式也可以按列指标的排成自然序，此时用行指标所成排列的奇偶性来决定该项的正负号。","link":"2023/07/07/%E8%A1%8C%E5%88%97%E5%BC%8F/"},{"title":"行列式的一道例题","text":"题目来自教材习题 2.2 第五题下述行列式是 x 的几次多项式?分别求出$x^4$和$x^3$的系数 $$\\begin{vmatrix}5x &amp; x &amp; 1 &amp; x \\\\1 &amp; x &amp; 1 &amp; -x \\\\3 &amp; 2 &amp; x &amp; 1 \\\\3 &amp; 1 &amp; 1 &amp; x\\end{vmatrix}$$ 能取到的最高项也就是主对角线的乘积，所以是 4 次多项式。其中一个四次项的系数是主对角线，也就是 5，可以选中一个 x 去凑另一个四次项，显然凑不出来。选择一行的 x 分别凑一个三次项，如图按行指标排列如下 $$a_{14}a_{22}a_{33}a_{41}$$ 列指标排列为 4231，其逆序数为 5，是奇排列，故系数为-3。再凑一个列指标排列为 2431，逆序数为 4，是偶排列，故系数为-3。列指标排列为 1432，逆序数为 3，是奇排列，故系数为 5 。列指标排列为 2134，逆序数为 1，是奇排列，故系数为-1。所以，三次项系数为-2。nnd 答案错了","link":"2023/07/13/%E8%A1%8C%E5%88%97%E5%BC%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%80%E9%81%93%E4%BE%8B%E9%A2%98/"},{"title":"第四节 行列式的性质","text":"性质 1一个矩阵的行列式按行和列排序结果是相同的，如果交换一个矩阵的行和列，其行列式是否会发生改变呢？ 答案是不变 $$设n级矩阵：A=(a_{ij})=\\begin{pmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\a_{n1} &amp;a_{n2} &amp; \\cdots &amp;a_{nn}\\end{pmatrix}$$ 把行列互换 $$A^\\top =\\begin{pmatrix}a_{11} &amp; a_{21} &amp; \\cdots &amp; a_{n1} \\\\a_{12} &amp; a_{22} &amp; \\cdots &amp; a_{n2} \\\\\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\a_{1n} &amp;a_{2n} &amp; \\cdots &amp;a_{nn}\\end{pmatrix}$$ 变换后的矩阵称为矩阵 A 的转置，记作$A’或A^\\top或A^t$。 $$|A^\\top| \\xlongequal[]{列指标成自然序}\\sum_{i_1i_2 \\cdots i_n} (-1)^{i_1i_2 \\cdots i_n}a_{1i_1}a_{2i_2}\\cdots a_{ni_n} \\xlongequal[]{行指标成自然序}|A|$$ 上式已在上篇文章证明。所以性质 1：$|A^\\top| = |A|$ 性质 2若 $A \\xrightarrow[]{第i行*k}B$，则 $$|B|: \\quad\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\ka_{i1} &amp; ka_{i2} &amp; \\cdots &amp; ka_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}=k|A|: \\quadk \\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}$$ 证明： $$\\begin{align}左边=&amp;\\sum_{j_1j_2 \\cdots j_n}(-1)^{\\tau(j_1j_2 \\cdots j_n)}a_{1j_1} \\cdots ka_{ij_i} \\cdots a_{nj_n} \\\\=&amp; k \\sum_{j_1j_2 \\cdots j_n}(-1)^{\\tau(j_1j_2 \\cdots j_n)}a_{1j_1} \\cdots a_{ij_i} \\cdots a_{nj_n} \\\\=&amp; 右边\\end{align}$$ 注：性质 2 中 k=0 也成立，行列式有一行全为零则值为零。 性质 3行列式中有某一行式两组数的和，则此行列式等于两个行列式的和，这两个行列式的这一行分别是第一组数和第二组数，而其余各行与原来行列式的相应各行相同，即 $$\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\第i行:b_1+c_1 &amp; b_2+c_2 &amp; \\cdots &amp; b_n+c_n \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}=\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\b_1 &amp; b_2 &amp; \\cdots &amp; b_n \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}+\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\c_1 &amp; c_2 &amp; \\cdots &amp; c_n \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}$$ 证明： $$\\begin{align}左边=&amp;\\sum_{j_1j_2 \\cdots j_n}(-1)^{\\tau(j_1j_2 \\cdots j_n)}a_{1j_1} \\cdots (b_{j_i}+c_{j_i}) \\cdots a_{nj_n} \\\\=&amp;\\sum_{j_1j_2 \\cdots j_n}(-1)^{\\tau(j_1j_2 \\cdots j_n)}a_{1j_1} \\cdots b_{j_i} \\cdots a_{nj_n} + \\sum_{j_1j_2 \\cdots j_n}(-1)^{\\tau(j_1j_2 \\cdots j_n)}a_{1j_1} \\cdots c_{j_i} \\cdots a_{nj_n}\\\\=&amp; 右边\\end{align}$$ 性质 4对于 2 阶行列式有 $$\\begin{align}\\begin{vmatrix}a_1 &amp; a_2 \\\\b_1 &amp; b_2\\end{vmatrix}=&amp; a_1b_2 - a_2b_1 \\\\\\begin{vmatrix}b_1 &amp; b_2 \\\\a_1 &amp; a_2\\end{vmatrix}=&amp;b_1a_2 - b_2a_1 = -(a_1b_2-a_2b_1)\\end{align}$$ n 阶行列式也有此性质：两行互换，行列式反号。 $$\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{k1} &amp; a_{k2} &amp; \\cdots &amp; a_{kn} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}=-\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{k1} &amp; a_{k2} &amp; \\cdots &amp; a_{kn} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}$$ 证明： $$\\begin{align}左边=&amp;-\\sum_{j_1 \\cdots j_i \\cdots j_n \\cdots j_n}(-1)^{\\tau(j_1 \\cdots j_k \\cdots j_i \\cdots j_n)}a_{1j_1} \\cdots a_{kj_i} \\cdots a_{ij_i} \\cdots a_{nj_n} \\\\=&amp; -\\sum_{j_1 \\cdots j_k \\cdots j_i \\cdots j_n}(-1)\\cdot(-1)^{\\tau(j_1 \\cdots j_k \\cdots j_i \\cdots j_n)}a_{1j_1} \\cdots a_{ij_i} \\cdots a_{kj_i} \\cdots a_{nj_n} \\\\=&amp; \\sum_{j_1 \\cdots j_k \\cdots j_i \\cdots j_n}(-1)^{\\tau(j_1 \\cdots j_k \\cdots j_i \\cdots j_n)}a_{1j_1} \\cdots a_{ij_i} \\cdots a_{kj_i} \\cdots a_{nj_n} \\\\=&amp; 右边\\end{align}$$ 性质 5如果两行相等，行列式的值为零。 $$\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}=0$$ 证明：根据性质 4，互换相同的那两行 $$\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}=-\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}$$ 都移到左边，二倍的行列式为零，所以行列式的值为零。 性质 6两行成比例，行列式的值为零。根据性质 5 和性质 2，提出一个常数再移项即可得到性质 5 的式子，所以行列式为零。 性质 7把一行的倍数加到另一行，行列式的值不变。 $$\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{k1}+la_{i1} &amp; a_{k2}+la_{i2} &amp; \\cdots &amp; a_{kn}+la_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}=\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{k1} &amp; a_{k2} &amp; \\cdots &amp; a_{kn} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}$$ 证明：根据性质 3 和性质 6 $$\\begin{align}左边=&amp;\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{k1} &amp; a_{k2} &amp; \\cdots &amp; a_{kn} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}+\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\la_{i1} &amp; la_{i2} &amp; \\cdots &amp; la_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix} \\\\=&amp;\\begin{vmatrix}a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{i1} &amp; a_{i2} &amp; \\cdots &amp; a_{in} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{k1} &amp; a_{k2} &amp; \\cdots &amp; a_{kn} \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{vmatrix}+0=右边\\end{align}$$ 例题 1：求 $$\\begin{vmatrix}k &amp; \\lambda &amp; \\lambda &amp; \\cdots &amp; \\lambda \\\\\\lambda &amp; k &amp; \\lambda &amp; \\cdots &amp; \\lambda \\\\\\lambda &amp; \\lambda &amp; k &amp; \\cdots &amp; \\lambda \\\\\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\\\\\lambda &amp; \\lambda &amp; \\lambda &amp; \\cdots &amp; k\\end{vmatrix}=?$$ 化成上三角形，先将各列加到第一列。 $$原式=\\begin{vmatrix}k+(n-1)\\lambda &amp; \\lambda &amp; \\lambda &amp; \\cdots &amp; \\lambda \\\\k+(n-1)\\lambda &amp; k &amp; \\lambda &amp; \\cdots &amp; \\lambda \\\\k+(n-1)\\lambda &amp; \\lambda &amp; k &amp; \\cdots &amp; \\lambda \\\\\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\\\k+(n-1)\\lambda &amp; \\lambda &amp; \\lambda &amp; \\cdots &amp; k\\end{vmatrix}=[k+(n-1)\\lambda]\\begin{vmatrix}1 &amp; \\lambda &amp; \\lambda &amp; \\cdots &amp; \\lambda \\\\1 &amp; k &amp; \\lambda &amp; \\cdots &amp; \\lambda \\\\1 &amp; \\lambda &amp; k &amp; \\cdots &amp; \\lambda \\\\\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\\\1 &amp; \\lambda &amp; \\lambda &amp; \\cdots &amp; k\\end{vmatrix}$$ 第一行的负一倍加到下一行。 $$=\\begin{vmatrix}1 &amp; \\lambda &amp; \\lambda &amp; \\cdots &amp; \\lambda \\\\0 &amp; k-\\lambda &amp; 0 &amp; \\cdots &amp; 0 \\\\0 &amp; 0 &amp; k-\\lambda &amp; \\cdots &amp; 0 \\\\\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\\\0 &amp; 0 &amp; 0 &amp; \\cdots &amp; k-\\lambda\\end{vmatrix}=[k+(n-1) \\lambda](k-\\lambda)^{n-1}$$","link":"2023/07/11/%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E6%80%A7%E8%B4%A8/"},{"title":"记香橙派的第一次启动","text":"1. 登录官方的 archlinux 系统默认带 xfce 桌面环境，由于 micro hdmi 线还没到，只能用 tty 交互。或许是需要图形化初始化默认账户和密码，官方提供的不能在 tty 登录。(待求证)注：官方手册里的默认账户密码不正确！！！！解决办法：用另一个开发板 chroot，更改 root 密码。 2. 系统优化2.1 镜像源以上是我挂代理情况下，且本地数据库是最新的，但仍然出现 404 报错，考虑添加 archlinuxarm 源来补全缺失的软件。更改/etc/pacman.d/mirrorlist 1234# 只保留Server = https://mirrors.bfsu.edu.cn/archlinuxarm/$arch/$repo# 复制# Server = http://nl.mirror.orangeinfra.online/unstable/$arch/$repo 更改/etc/pacman.conf 123[opios]#Include = /etc/pacman.d/mirrorlistServer = http://nl.mirror.orangeinfra.online/unstable/$arch/$repo 然后执行 1sudo pacman -Syy 这样，软件就可以正常下载了。 卸载桌面环境（如果需要）1sudo pacman -Rsc xfce4 xorg","link":"2023/07/17/%E8%AE%B0%E9%A6%99%E6%A9%99%E6%B4%BE%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%AF%E5%8A%A8/"},{"title":"香橙派zero3 I2C oled连接测试","text":"板子：香橙派zero3 2gb镜像：orange os (arch linux)先贴张引脚图 可见，可以扩展的是I2C-3这个镜像系统默认不开启i2c-3，也没有官方的配置工具orangepi-config，所以需要我们手动开启i2c-3。打开/boot/extlinux/extlinux.conf，在FDT下面一行添加FDTOVERLAYS 1FDTOVERLAYS /dtbs/allwinner/overlay/sun50i-h616-ph-i2c3.dtbo 重启系统，查看/dev/i2c-* 12$ls /dev/i2c-*/dev/i2c-3 /dev/i2c-4 /dev/i2c-5 i2c-3已经启用，接着进行测试安装i2c-tools 12sudo pacman -S i2c-toolssudo i2cdetect -y 3 下载wiringOP获取示例代码 12345git clone https://github.com/orangepi-xunlong/wiringOPmkdir test &amp;&amp; cd testcp ../wiringOP/examples/oled_demo.c .gcc -lwiringPi oled_demo.csudo ./a.out /dev/i2c-3 此时oled出现画面","link":"2023/07/17/%E9%A6%99%E6%A9%99%E6%B4%BEzero3%E7%82%B9%E4%BA%AEi2c-oled%E5%B1%8F%E5%B9%95/"},{"title":"高等代数的研究对象","text":"tag: 线性代数 是我自学线性代数的笔记，视频课程是 b 站上北大教授丘维声讲授的。笔记内容较为凌乱，我的目的是给我自己看，所以内容仅供参考，有什么问题欢迎在底部评论提出！ 一元高次方程一个未知量，次数无限大，研究方程的根是如何，以及有没有求根公式。这是经典代数研究的中心问题。 n 元一次方程组举例：以下是四个方程的三元一次方程组。 $$ \\begin{cases} x_1+3x_2+x_3=2 \\\\\\ 3x_1+4x_2+2x_3=9 \\\\ -x_1-5x_2+4x_3=10 \\\\ 2x_1+7x_2+x_3=1 \\end{cases}$$ 借用平面解析几何的思想，把关于 x, y 的一次关系称为线性关系，那么 n 元一次方程组又叫n 元线性方程组。n 元线性方程组的表示方法： $$(1):\\begin{cases}a_{11}x_1 + a_{12}x_2 + \\cdots + a_{1n}x_n=b_1 \\\\\\cdots \\cdots \\\\a_{s1}x_1+a_{s2}x_2+\\cdots+a_{sn}x_x=b_s\\end{cases}$$ 左侧都是未知量，右侧都是常量。解法，消元法：都会，不必说。其本质是系数做加减和倍数运算，那我们可以省略未知量 $x_1, x_2 \\cdots x_n$把系数以表的形式列出，就会得到矩阵。 矩阵以上一个三元方程组为例，其系数构成的矩阵如下。 $$\\begin{pmatrix}1&amp;3&amp;1\\\\3&amp;4&amp;2\\\\-1&amp;-5&amp;4\\\\2&amp;7&amp;1\\\\\\end{pmatrix}$$ 纵为列，横为行，构成 4 行 4 列的 4x4 的矩阵，简称 4 级矩阵。那么 s 行，n 列，有 s*n 个数排成 s 行 n 列的表，就是一个s*n 矩阵。其中每个数称为这个矩阵的一个元素，第 i 行与第 j 列交叉位置的元素称为矩阵的(i,j)元。如果矩阵的(i,j)元是$a_{ij}$,那么可以记作$A=(a_{ij})$。元素全为零的矩阵称为零矩阵，简记为 0，s 行 m 列的零矩阵记作$0_{s*m}$。如果一个矩阵的行数和列数相等，则称它为方阵。m 行 m 列的方阵称为m 级矩阵。 $$A = \\begin{pmatrix}a_{11}&amp;a_{12}&amp;\\cdots&amp;a_{1n}\\\\a_{21}&amp;a_{22}&amp;\\cdots&amp;a_{2n}\\\\\\cdots \\cdots\\\\a_{s1}&amp;a_{s2}&amp;\\cdots&amp;a_{sn}\\end{pmatrix}$$ 矩阵可用大写字母表示，如矩阵 A。A 为方程(1)的系数组成的，叫做(1)的系数矩阵。 $$B = \\begin{pmatrix}a_{11}&amp;a_{12}&amp;\\cdots&amp;a_{1n}&amp;b_1\\\\a_{21}&amp;a_{22}&amp;\\cdots&amp;a_{2n}&amp;b_2\\\\\\cdots \\cdots\\\\a_{s1}&amp;a_{s2}&amp;\\cdots&amp;a_{sn}&amp;b_s\\end{pmatrix}$$ B 由方程（1）的系数和常数组成构成 s*(n+1)矩阵，叫做（1）的增广矩阵，其对我们求解有很大的作用，接着就会讲解法。总之，高等代数的研究对象的出发点就是n 元线性方程组，解法就是矩阵。那么，解有哪些情况呢？可以再次借助平面几何的思想，两个直线相交有唯一的交点，也就是一个解。平行无交点，重合无穷多个交点。 n 元，n 维，n 维向量一元是线，二元是平面，三元是空间，四元是时空，对应着一维，二维，三维，四维。那么五维又是什么概念呢？要想理解五维及更高维度，我们可以研究线性方程中解的情况的判别。以系数矩阵 A 为例当 n 为 2 时，两个数字组成了二元有序数组，就是平面向量的坐标。n 为 3，n 为 4，同理。那么我们可以扩展到 n 维，成为 n 维向量，引入运算法则（加法、运算律、数乘、零向量、反向量）构成 n 维向量空间。这样我们就可以研究解情况的判别和解集的结构了。进一步，结合 n 维向量空间的性质抽象出了线性空间的概念。高维的概念可以投影到线性空间中，叫做线性映射。只有加法和数乘的线性空间并不能涵盖向量的所有特性，例如，长度，方向，两个向量的夹角。要想将度量介入其中，可引入内积。 内积高中我们已经了解了他的定义式 $$\\vec a \\cdot \\vec b=|\\vec a||\\vec b|\\cos &lt;\\vec a,\\vec b&gt;$$ 两个向量的内积是一个数，所以内积是一个二元函数，也称为双线性函数。借助内积，线性空间称为了具有度量的线性空间。 欧几里得空间：实数域，具有度量的线性空间。有限维，例如三维空间。 酉空间：复数域，具有度量的线性空间。 …还有其他空间 空间到自身的线性映射（投影）叫线性变换。 欧几里得空间：正交变换，对称变换 酉空间：酉变换，Hermite 变换 ..还有其他变换 线性代数的主线是研究线性空间和线性映射。 一元高次方程的求根$a_nx^n+a_{n-1}+\\cdots+a_1x+a_0=0$以一元二次方程为例，我们的获得求根公式的方法是配方，也可以因式分解。所以左侧的一元多项式（一元多项式环）要进行因式分解，就要研究一元多项式的结构。伽罗瓦证明了五次和五次以上的方程没有求根公式，同时也提出了有根式解的充分必要条件是此方程的群是可解群。他的理论还引进了域的概念和群的概念，让代数学的研究对象发生了革命性的变革，经典代数研究一元高次方程的求根，现代近似代数学（抽象代数学）研究环、域、群系统的结构以及三者保持运算的映射。我们不去研究抽象代数的具体内容（幸好不学），只是引入了环群域的概念。 高等代数研究对象的第二部分就是一元或 n 元多项式环的结构和通用性质。 学习方法数学思维的思维方式 观察客观现象（纷繁复杂）：联系生活，提出问题，研究问题。 抓住主要特征：抽象出概念，建立模型。（概念非常多） 探索结构：应用直觉，几何（可以看 3b1b 的视频），类比，归纳，联想，推理。 猜测可能有的规律 认证：深入分析，运用定义，公理，已经证明的定理进行逻辑推理。（地狱难度） 揭示事物的内在规律（井然有序）","link":"2023/06/14/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0%E7%9A%84%E7%A0%94%E7%A9%B6%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"Python","slug":"Python","link":"tags/Python/"},{"name":"算法","slug":"算法","link":"tags/%E7%AE%97%E6%B3%95/"},{"name":"线性代数","slug":"线性代数","link":"tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"香橙派","slug":"香橙派","link":"tags/%E9%A6%99%E6%A9%99%E6%B4%BE/"}],"categories":[{"name":"Python","slug":"Python","link":"categories/Python/"},{"name":"编程语言","slug":"编程语言","link":"categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"C","link":"categories/C/"},{"name":"高数","slug":"高数","link":"categories/%E9%AB%98%E6%95%B0/"},{"name":"Python","slug":"编程语言/Python","link":"categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"},{"name":"开发板","slug":"开发板","link":"categories/%E5%BC%80%E5%8F%91%E6%9D%BF/"},{"name":"线性代数","slug":"高数/线性代数","link":"categories/%E9%AB%98%E6%95%B0/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"香橙派","slug":"开发板/香橙派","link":"categories/%E5%BC%80%E5%8F%91%E6%9D%BF/%E9%A6%99%E6%A9%99%E6%B4%BE/"}],"pages":[{"title":"关于","text":"技术博客，会发一些问题的解决办法，和我的学习笔记。 ✨ 主要内容 hexo 框架 前端 Python C/C++ Linux Arduino ESP32 高数 深度学习 PyTorch C++算法 ❤️ 联系方式Github：https://github.com/PengunixQQ：3055255696WeChat：Pengunix_邮箱：hoshimaemi@outlook.comBilibili：https://space.bilibili.com/357944209","link":"about/index.html"},{"title":"categories","text":"","link":"categories/index.html"},{"title":"tags","text":"","link":"tags/index.html"}]}